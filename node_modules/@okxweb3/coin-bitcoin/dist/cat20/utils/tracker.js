"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMintRemainingSupply = exports.getTokenUtxo = void 0;
const common_1 = require("../common");
const utils_1 = require("./utils");
const paramsUtils_1 = require("./paramsUtils");
const scrypt_ts_1 = require("scrypt-ts");
function getTokenUtxo(txhex, operation, address) {
    const tx = new common_1.btc.Transaction(txhex);
    let indexes = [];
    let states = [];
    let txoStateHashes;
    if (operation == 'transfer') {
        const witness = tx.inputs[1].witnesses;
        const addrHash = (0, utils_1.toTokenAddress)(address);
        const stateHashes = witness.slice(0, 5);
        const ownerPubKeyHashes = witness.slice(5, 10);
        const tokenAmounts = witness.slice(10, 15);
        for (let i = 0; i < 5; i++) {
            const ownerPubKeyHash = ownerPubKeyHashes[i].toString('hex');
            if (ownerPubKeyHash != addrHash) {
                continue;
            }
            indexes.push(i + 1);
            const tokenAmount = tokenAmounts[i];
            if (tokenAmount.length == 0) {
                continue;
            }
            states.push({
                address: ownerPubKeyHash,
                amount: tokenAmount.readIntLE(0, tokenAmount.length).toString()
            });
        }
        txoStateHashes = stateHashes.map((s) => s.toString('hex'));
    }
    else if (operation == 'mint') {
        const witness = tx.inputs[0].witnesses;
        const stateHashes = witness.slice(0, 5);
        const ownerPubKeyHash = witness[5];
        const tokenAmount = witness[6];
        states.push({
            address: ownerPubKeyHash.toString('hex'),
            amount: tokenAmount.readIntLE(0, tokenAmount.length).toString()
        });
        txoStateHashes = stateHashes.map((s) => s.toString('hex'));
        indexes.push(tx.outputs.findIndex((o) => o.satoshis == 330));
    }
    return states.map((state, i) => {
        const outputIndex = indexes[i];
        return {
            utxo: {
                txId: tx.id,
                outputIndex,
                script: tx.outputs[outputIndex].script.toHex(),
                satoshis: tx.outputs[outputIndex].satoshis,
            },
            txoStateHashes,
            state,
        };
    });
}
exports.getTokenUtxo = getTokenUtxo;
function getMintRemainingSupply(txhex, tokenMetadata, vout) {
    const metadata = (0, paramsUtils_1.tokenInfoParse)(tokenMetadata, common_1.SupportedNetwork.fractalMainnet);
    const info = metadata.info;
    const scaledInfo = (0, paramsUtils_1.scaleConfig)(info);
    const minterP2TR = (0, utils_1.toP2tr)(metadata.minterAddr);
    const tx = new common_1.btc.Transaction(txhex);
    if (tx.id === metadata.revealTxid) {
        if (metadata.info.minterMd5 == common_1.MinterType.OPEN_MINTER_V2) {
            return scaledInfo.max / scaledInfo.limit;
        }
        return scaledInfo.max;
    }
    for (let i = 0; i < tx.inputs.length; i++) {
        const witnesses = tx.inputs[i].getWitnesses();
        if (witnesses.length > 2) {
            const lockingScriptBuffer = witnesses[witnesses.length - 2];
            const { p2tr } = (0, utils_1.script2P2TR)(lockingScriptBuffer);
            if (p2tr === minterP2TR) {
                return (0, scrypt_ts_1.byteString2Int)(witnesses[6 + vout].toString('hex'));
            }
        }
    }
}
exports.getMintRemainingSupply = getMintRemainingSupply;
//# sourceMappingURL=tracker.js.map