"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaleConfig = exports.minterParse = exports.tokenUtxoParse = exports.feeUtxoParse = exports.tokenInfoParse = void 0;
const common_1 = require("../common");
const cat_smartcontracts_1 = require("@cat-protocol/cat-smartcontracts");
const scrypt_ts_1 = require("scrypt-ts");
const utils_1 = require("./utils");
function tokenInfoParse(tokenStr, network) {
    const token = JSON.parse(tokenStr);
    const tokenInfo = JSON.parse(JSON.stringify(token.info));
    if (tokenInfo.max) {
        tokenInfo.max = BigInt(tokenInfo.max);
        tokenInfo.premine = BigInt(tokenInfo.premine);
        tokenInfo.limit = BigInt(tokenInfo.limit);
    }
    token.info = tokenInfo;
    if (!token.tokenAddr) {
        const minterP2TR = (0, utils_1.toP2tr)(token.minterAddr);
        token.tokenAddr = (0, utils_1.p2tr2Address)((0, utils_1.getTokenContractP2TR)(minterP2TR).p2tr, network);
    }
    return token;
}
exports.tokenInfoParse = tokenInfoParse;
function feeUtxoParse(ecKey, utxos) {
    return utxos.map((utxo) => {
        let scriptPk = common_1.btc.Script.fromAddress(ecKey.getAddress()).toHex();
        return {
            txId: utxo.txId,
            outputIndex: utxo.vOut,
            script: scriptPk,
            satoshis: utxo.amount,
        };
    });
}
exports.feeUtxoParse = feeUtxoParse;
function tokenUtxoParse(tokenUtxos) {
    let utxos = JSON.parse(tokenUtxos);
    if (!Array.isArray(utxos)) {
        utxos = [utxos];
    }
    return utxos.map((c) => {
        const protocolState = cat_smartcontracts_1.ProtocolState.fromStateHashList(c.txoStateHashes);
        if (typeof c.utxo.satoshis === 'string') {
            c.utxo.satoshis = parseInt(c.utxo.satoshis);
        }
        let ownerAddr = c.state.address;
        try {
            ownerAddr = (0, utils_1.toTokenAddress)(c.state.address);
        }
        catch {
        }
        const r = {
            utxo: c.utxo,
            state: {
                protocolState,
                data: {
                    ownerAddr: ownerAddr,
                    amount: BigInt(c.state.amount),
                },
            },
        };
        return r;
    });
}
exports.tokenUtxoParse = tokenUtxoParse;
function minterParse(minterStr, metadata, rawTx) {
    const minter = JSON.parse(minterStr);
    const protocolState = cat_smartcontracts_1.ProtocolState.fromStateHashList(minter.txoStateHashes);
    const data = getOpenMinterState(metadata, minter.utxo.txId, minter.utxo.outputIndex, rawTx);
    if (data === null) {
        throw new Error(`get open minter state failed, minter: ${metadata.minterAddr}, txId: ${minter.utxo.txId}`);
    }
    if (typeof minter.utxo.satoshis === 'string') {
        minter.utxo.satoshis = parseInt(minter.utxo.satoshis);
    }
    return {
        utxo: minter.utxo,
        state: {
            protocolState,
            data,
        },
    };
}
exports.minterParse = minterParse;
const getOpenMinterState = function (metadata, txId, vout, txhex) {
    const minterP2TR = (0, utils_1.toP2tr)(metadata.minterAddr);
    const tokenP2TR = (0, utils_1.toP2tr)(metadata.tokenAddr);
    const info = metadata.info;
    const scaledInfo = scaleConfig(info);
    if (txId === metadata.revealTxid) {
        if (metadata.info.minterMd5 == common_1.MinterType.OPEN_MINTER_V2) {
            return {
                isPremined: false,
                remainingSupplyCount: (scaledInfo.max - scaledInfo.premine) / scaledInfo.limit,
                tokenScript: tokenP2TR,
            };
        }
        return {
            isPremined: false,
            remainingSupply: scaledInfo.max - scaledInfo.premine,
            tokenScript: tokenP2TR,
        };
    }
    const tx = new common_1.btc.Transaction(txhex);
    if (tx.id != txId) {
        throw new Error(`Invalid raw tx, \n${txId} \n${tx.id}`);
    }
    const REMAININGSUPPLY_WITNESS_INDEX = 16;
    for (let i = 0; i < tx.inputs.length; i++) {
        const witnesses = tx.inputs[i].getWitnesses();
        if (witnesses.length > 2) {
            const lockingScriptBuffer = witnesses[witnesses.length - 2];
            const { p2tr } = (0, utils_1.script2P2TR)(lockingScriptBuffer);
            if (p2tr === minterP2TR) {
                if (metadata.info.minterMd5 == common_1.MinterType.OPEN_MINTER_V2) {
                    return {
                        tokenScript: witnesses[REMAININGSUPPLY_WITNESS_INDEX - 2].toString('hex'),
                        isPremined: true,
                        remainingSupplyCount: (0, scrypt_ts_1.byteString2Int)(witnesses[6 + vout].toString('hex')),
                    };
                }
                return {
                    tokenScript: witnesses[REMAININGSUPPLY_WITNESS_INDEX - 2].toString('hex'),
                    isPremined: true,
                    remainingSupply: (0, scrypt_ts_1.byteString2Int)(witnesses[6 + vout].toString('hex')),
                };
            }
        }
    }
    return null;
};
function scaleConfig(config) {
    const clone = Object.assign({}, config);
    clone.max = (0, utils_1.scaleByDecimals)(config.max, config.decimals);
    clone.premine = (0, utils_1.scaleByDecimals)(config.premine, config.decimals);
    clone.limit = (0, utils_1.scaleByDecimals)(config.limit, config.decimals);
    return clone;
}
exports.scaleConfig = scaleConfig;
//# sourceMappingURL=paramsUtils.js.map