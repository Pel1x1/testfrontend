"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EcKeyService = void 0;
const btc = require("bitcore-lib-inquisition");
const common_1 = require("../common");
const scrypt_ts_1 = require("scrypt-ts");
const utils_1 = require("./utils");
class EcKeyService {
    constructor(opts) {
        this.addressType = opts.addressType || common_1.CatAddressType.P2TR;
        if (!opts.privateKey && !opts.publicKey) {
            throw new Error('Either privateKey or publicKey must be provided');
        }
        this.privateKey = opts.privateKey ? btc.PrivateKey.fromWIF(opts.privateKey) : undefined;
        this.publicKey = opts.privateKey ? this.privateKey.toPublicKey() : btc.PublicKey.fromString(opts.publicKey);
    }
    hasPrivateKey() {
        return this.privateKey !== undefined;
    }
    getWif() {
        return this.getPrivateKey().toWIF();
    }
    getPrivateKey() {
        return this.privateKey;
    }
    getAddressType() {
        return this.addressType || common_1.CatAddressType.P2TR;
    }
    ;
    getP2TRAddress() {
        return this.getPublicKey().toAddress(null, btc.Address.PayToTaproot);
    }
    getAddress() {
        return this.getP2TRAddress();
    }
    getXOnlyPublicKey() {
        const pubkey = this.getTokenPublicKey();
        return (0, utils_1.toXOnly)(pubkey.toBuffer()).toString('hex');
    }
    getTweakedPrivateKey() {
        const { tweakedPrivKey } = this.getPrivateKey().createTapTweak();
        return btc.PrivateKey.fromBuffer(tweakedPrivKey);
    }
    getPublicKey() {
        return this.publicKey;
    }
    getTokenPublicKey() {
        const addressType = this.getAddressType();
        if (addressType === common_1.CatAddressType.P2TR) {
            const { tweakedPubKey } = this.publicKey.createTapTweak();
            return btc.PublicKey.fromBuffer(tweakedPubKey);
        }
        return this.publicKey;
    }
    getPubKeyPrefix() {
        const addressType = this.getAddressType();
        if (addressType === common_1.CatAddressType.P2TR) {
            return '';
        }
        else if (addressType === common_1.CatAddressType.P2WPKH) {
            const pubkey = this.getTokenPublicKey();
            return pubkey.toString().slice(0, 2);
        }
        return '';
    }
    getTokenAddress() {
        const addressType = this.getAddressType();
        if (addressType === common_1.CatAddressType.P2TR) {
            const xpubkey = this.getXOnlyPublicKey();
            return (0, scrypt_ts_1.hash160)(xpubkey);
        }
        else if (addressType === common_1.CatAddressType.P2WPKH) {
            const pubkey = this.getTokenPublicKey();
            return (0, scrypt_ts_1.hash160)(pubkey.toString());
        }
        else {
            throw new Error(`Unsupported address type: ${addressType}`);
        }
    }
    getTaprootPrivateKey() {
        return this.getTweakedPrivateKey();
    }
    getTokenPrivateKey() {
        const addressType = this.getAddressType();
        if (addressType === common_1.CatAddressType.P2TR) {
            return this.getTaprootPrivateKey();
        }
        else if (addressType === common_1.CatAddressType.P2WPKH) {
            return this.getPrivateKey();
        }
        else {
            throw new Error(`Unsupported address type: ${addressType}`);
        }
    }
    signTx(tx) {
        if (!this.hasPrivateKey()) {
            throw new Error('No private key provided');
        }
        const privateKey = this.getPrivateKey();
        const hashData = btc.crypto.Hash.sha256ripemd160(privateKey.publicKey.toBuffer());
        for (let i = 0; i < tx.inputs.length; i++) {
            const input = tx.inputs[i];
            if (input.output.script.isWitnessPublicKeyHashOut()) {
                const signatures = input.getSignatures(tx, privateKey, i, undefined, hashData, undefined, undefined);
                if (signatures.length === 0) {
                    throw new Error('Could not sign input');
                }
                tx.applySignature(signatures[0]);
            }
            else if (input.output.script.isTaproot() && !input.hasWitnesses()) {
                const signatures = input.getSignatures(tx, privateKey, i, btc.crypto.Signature.SIGHASH_ALL, hashData, undefined, undefined);
                if (signatures.length === 0) {
                    throw new Error('Could not sign input');
                }
                tx.applySignature(signatures[0]);
            }
        }
    }
}
exports.EcKeyService = EcKeyService;
//# sourceMappingURL=eckey.js.map