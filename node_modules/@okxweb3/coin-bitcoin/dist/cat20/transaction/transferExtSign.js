"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildTxWithSig = exports.buildSighashes = void 0;
const common_1 = require("../common");
const scrypt_ts_1 = require("scrypt-ts");
const utils_1 = require("../utils");
const cat_smartcontracts_1 = require("@cat-protocol/cat-smartcontracts");
const decimal_js_1 = __importDefault(require("decimal.js"));
const functions_1 = require("./functions");
const merge_1 = require("./merge");
const transfer_1 = require("./transfer");
async function build(param) {
    const txParams = param.data;
    const ecKey = new utils_1.EcKeyService({
        publicKey: txParams.publicKey,
    });
    let metadata = (0, utils_1.tokenInfoParse)(txParams.tokenMetadata, common_1.SupportedNetwork.fractalMainnet);
    const minterP2TR = (0, utils_1.toP2tr)(metadata.minterAddr);
    const { p2tr: tokenP2TR, tapScript: tokenTapScript } = (0, utils_1.getTokenContractP2TR)(minterP2TR);
    let verifyScript = txParams.verifyScript || false;
    let receiver;
    let amount;
    try {
        receiver = common_1.btc.Address.fromString(txParams.toAddress);
    }
    catch (error) {
        throw new Error(`Invalid receiver address: ${txParams.toAddress}`);
    }
    if (receiver.type !== 'taproot') {
        throw new Error(`Invalid address type: ${receiver.type}`);
    }
    const scaledInfo = (0, utils_1.scaleConfig)(metadata.info);
    try {
        const d = new decimal_js_1.default(txParams.tokenAmount).mul(Math.pow(10, scaledInfo.decimals));
        amount = BigInt(d.toString());
    }
    catch (error) {
        throw new Error(`Invalid token amount:  ${txParams.tokenAmount}`);
    }
    if (amount <= 0n) {
        throw new Error('Invalid token amount');
    }
    const feeUtxos = (0, utils_1.feeUtxoParse)(ecKey, param.data.feeInputs);
    let feeUtxo = feeUtxos[0];
    let mergeTx;
    if (feeUtxos.length > 1) {
        ({ feeUtxo, mergeTx } = (0, merge_1.mergeFee)(ecKey, feeUtxos, txParams.feeRate));
    }
    let tokens = (0, utils_1.tokenUtxoParse)(txParams.tokens);
    const commitResult = (0, functions_1.createGuardContract)(ecKey, feeUtxo, txParams.feeRate, tokens, tokenP2TR, txParams.changeAddress);
    if (commitResult === null) {
        throw new Error('commit fail');
    }
    const { commitTx, contact: guardContract, guardTapScript } = commitResult;
    const newState = cat_smartcontracts_1.ProtocolState.getEmptyState();
    const receiverTokenState = cat_smartcontracts_1.CAT20Proto.create(amount, (0, utils_1.toTokenAddress)(receiver));
    newState.updateDataList(0, cat_smartcontracts_1.CAT20Proto.toByteString(receiverTokenState));
    const tokenInputAmount = tokens.reduce((acc, t) => acc + t.state.data.amount, 0n);
    const changeTokenInputAmount = tokenInputAmount - amount;
    let changeTokenState = null;
    if (changeTokenInputAmount > 0n) {
        const tokenChangeAddress = ecKey.getTokenAddress();
        changeTokenState = cat_smartcontracts_1.CAT20Proto.create(changeTokenInputAmount, tokenChangeAddress);
        newState.updateDataList(1, cat_smartcontracts_1.CAT20Proto.toByteString(changeTokenState));
    }
    const newFeeUtxo = {
        txId: commitTx.id,
        outputIndex: 2,
        script: commitTx.outputs[2].script.toHex(),
        satoshis: commitTx.outputs[2].satoshis,
    };
    const inputUtxos = [
        ...tokens.map((t) => t.utxo),
        guardContract.utxo,
        newFeeUtxo,
    ];
    if (inputUtxos.length > cat_smartcontracts_1.MAX_INPUT) {
        throw new Error('Too many inputs, max 4 token inputs');
    }
    const revealTx = new common_1.btc.Transaction()
        .from(inputUtxos)
        .addOutput(new common_1.btc.Transaction.Output({
        satoshis: 0,
        script: (0, utils_1.toStateScript)(newState),
    }))
        .addOutput(new common_1.btc.Transaction.Output({
        satoshis: common_1.Postage.TOKEN_POSTAGE,
        script: tokenP2TR,
    }))
        .feePerByte(txParams.feeRate);
    if (changeTokenState) {
        revealTx.addOutput(new common_1.btc.Transaction.Output({
            satoshis: common_1.Postage.TOKEN_POSTAGE,
            script: tokenP2TR,
        }));
    }
    const satoshiChangeScript = common_1.btc.Script.fromAddress(txParams.changeAddress);
    revealTx.addOutput(new common_1.btc.Transaction.Output({
        satoshis: 0,
        script: satoshiChangeScript,
    }));
    let tokenTxs = [];
    if (txParams.tokenPrevTxs.length !== tokens.length) {
        throw new Error('Invalid tokenPrevTxs length');
    }
    for (let i = 0; i < tokens.length; i++) {
        const prevTx = txParams.tokenPrevTxs[i].prevTx;
        const prevPrevTx = txParams.tokenPrevTxs[i].prevPrevTx;
        const res = (0, utils_1.validatePrevTx)(metadata, prevTx, prevPrevTx, common_1.SupportedNetwork.fractalMainnet);
        if (res === null) {
            throw new Error('prevTx does not match prevPrevTx');
        }
        tokenTxs.push(res);
    }
    const guardCommitTxHeader = (0, cat_smartcontracts_1.getTxHeaderCheck)(commitTx, guardContract.utxo.outputIndex);
    const guardInputIndex = tokens.length;
    const guardInfo = {
        outputIndex: (0, utils_1.toTxOutpoint)(guardContract.utxo.txId, guardContract.utxo.outputIndex).outputIndex,
        inputIndexVal: BigInt(guardInputIndex),
        tx: guardCommitTxHeader.tx,
        guardState: guardContract.state.data,
    };
    const vsize = await (0, transfer_1.calcVsizeTransfer)(tokens, guardContract, revealTx, guardInfo, tokenTxs, tokenTapScript, guardTapScript, newState, receiverTokenState, changeTokenState, satoshiChangeScript, minterP2TR);
    const satoshiChangeAmount = revealTx.inputAmount - vsize * txParams.feeRate - common_1.Postage.TOKEN_POSTAGE - (changeTokenState === null ? 0 : common_1.Postage.TOKEN_POSTAGE);
    if (satoshiChangeAmount <= common_1.CHANGE_MIN_POSTAGE) {
        throw new Error('Insufficient satoshis balance!');
    }
    const satoshiChangeOutputIndex = changeTokenState === null ? 2 : 3;
    revealTx.outputs[satoshiChangeOutputIndex].satoshis = satoshiChangeAmount;
    console.log(guardTapScript);
    const txCtxs = (0, cat_smartcontracts_1.getTxCtxMulti)(revealTx, tokens.map((_, i) => i).concat([tokens.length]), [
        ...new Array(tokens.length).fill(Buffer.from(tokenTapScript, 'hex')),
        Buffer.from(guardTapScript, 'hex'),
    ]);
    const changeInfo = {
        script: (0, scrypt_ts_1.toByteString)(satoshiChangeScript.toHex()),
        satoshis: (0, scrypt_ts_1.int2ByteString)(BigInt(satoshiChangeAmount), 8n),
    };
    const commitFeeInputIndex = 0;
    const revealFeeInputIndex = revealTx.inputs.length - 1;
    return {
        txParams,
        ecKey,
        tokens,
        tokenTxs,
        guardInfo,
        minterP2TR,
        verifyScript,
        guardContract,
        guardInputIndex,
        newState,
        receiverTokenState,
        changeTokenState,
        changeInfo,
        mergeTx,
        commitTx,
        revealTx,
        txCtxs,
        commitFeeInputIndex,
        revealFeeInputIndex,
    };
}
async function buildSighashes(param) {
    const { mergeTx, commitTx, revealTx, txCtxs, commitFeeInputIndex, revealFeeInputIndex, } = await build(param);
    function getSigHashSchnorrNonTapScript(transaction, inputIndex = 0, sigHashType = 0x00) {
        const execdata = {
            annexPresent: false,
            annexInit: true,
        };
        return common_1.btc.Transaction.SighashSchnorr.sighash(transaction, sigHashType, inputIndex, 2, execdata);
    }
    console.log(revealTx.uncheckedSerialize());
    const sighashes = {
        merge: mergeTx ?
            mergeTx.inputs.map((_, i) => {
                return getSigHashSchnorrNonTapScript(mergeTx, i).toString('hex');
            }) : [],
        commit: [getSigHashSchnorrNonTapScript(commitTx, commitFeeInputIndex).toString('hex')],
        reveal: [
            ...txCtxs.slice(0, txCtxs.length - 1).map((txCtx, i) => {
                return txCtx.sighash.hash.toString('hex');
            }),
            getSigHashSchnorrNonTapScript(revealTx, revealFeeInputIndex).toString('hex')
        ]
    };
    return sighashes;
}
exports.buildSighashes = buildSighashes;
async function buildTxWithSig(param) {
    const { txParams, ecKey, tokens, tokenTxs, guardInfo, minterP2TR, verifyScript, guardContract, guardInputIndex, newState, receiverTokenState, changeTokenState, changeInfo, mergeTx, commitTx, revealTx, txCtxs, commitFeeInputIndex, revealFeeInputIndex, } = await build(param);
    const signData = txParams.signData;
    if (!signData) {
        throw new Error('No signData');
    }
    if (signData.commit.length != commitTx.inputs.length) {
        throw new Error('Wrong number of commit signatures');
    }
    for (let i = 0; i < tokens.length; i++) {
        const signature = txParams.signData ? txParams.signData.reveal[i] : undefined;
        const res = await (0, functions_1.unlockToken)(ecKey, tokens[i], i, tokenTxs[i].prevTx, tokenTxs[i].prevTokenInputIndex, tokenTxs[i].prevPrevTx, guardInfo, revealTx, minterP2TR, txCtxs[i], verifyScript, signature);
        if (!res) {
            return null;
        }
    }
    const res = await (0, functions_1.unlockGuard)(guardContract, guardInfo, guardInputIndex, newState, revealTx, receiverTokenState, changeTokenState, changeInfo, txCtxs[guardInputIndex], verifyScript);
    if (!res) {
        return null;
    }
    if (mergeTx) {
        if (signData.merge.length != mergeTx.inputs.length) {
            throw new Error('Wrong number of merge signatures');
        }
        for (let i = 0; i < mergeTx.inputs.length; i++) {
            const sig = {
                signature: common_1.btc.crypto.Signature.fromString(Buffer.from(signData.merge[i], 'hex')),
                inputIndex: i
            };
            if (!mergeTx.inputs[i].isValidSignature(mergeTx, sig)) {
                throw new Error(`merge tx input ${i}'s signature is invalid`);
            }
            mergeTx.applySignature(sig);
        }
    }
    if (signData.commit.length != commitTx.inputs.length) {
        throw new Error('Wrong number of commit signatures');
    }
    const commitSig = {
        signature: common_1.btc.crypto.Signature.fromBuffer(Buffer.from(signData.commit[0], 'hex')),
        inputIndex: commitFeeInputIndex
    };
    if (!commitTx.inputs[commitFeeInputIndex].isValidSignature(commitTx, commitSig)) {
        throw new Error(`commit tx input ${commitFeeInputIndex}'s signature is invalid`);
    }
    commitTx.applySignature(commitSig);
    const revealSig = {
        signature: common_1.btc.crypto.Signature.fromBuffer(Buffer.from(signData.reveal[tokens.length], 'hex')),
        inputIndex: revealFeeInputIndex
    };
    if (!revealTx.inputs[revealFeeInputIndex].isValidSignature(revealTx, revealSig)) {
        throw new Error(`reveal tx input ${revealFeeInputIndex}'s signature is invalid`);
    }
    revealTx.applySignature(revealSig);
    return {
        mergeTx: mergeTx ? mergeTx.uncheckedSerialize() : null,
        commitTx: commitTx.uncheckedSerialize(),
        revealTx: revealTx.uncheckedSerialize(),
    };
}
exports.buildTxWithSig = buildTxWithSig;
//# sourceMappingURL=transferExtSign.js.map