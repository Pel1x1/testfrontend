"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPremineAddress = exports.getRemainSupply = exports.pickOpenMinterStateField = exports.createOpenMinterState = exports.unlockGuardMulti = exports.unlockGuard = exports.unlockToken = exports.createGuardContract = void 0;
const common_1 = require("../common");
const utils_1 = require("../utils");
const cat_smartcontracts_1 = require("@cat-protocol/cat-smartcontracts");
const scrypt_ts_1 = require("scrypt-ts");
function createGuardContract(ecKey, feeutxo, feeRate, tokens, tokenP2TR, changeAddress) {
    const { p2tr: guardP2TR, tapScript: guardTapScript } = (0, utils_1.getGuardsP2TR)();
    const protocolState = cat_smartcontracts_1.ProtocolState.getEmptyState();
    const realState = cat_smartcontracts_1.GuardProto.createEmptyState();
    realState.tokenScript = tokenP2TR;
    for (let i = 0; i < tokens.length; i++) {
        realState.inputTokenAmountArray[i] = tokens[i].state.data.amount;
    }
    protocolState.updateDataList(0, cat_smartcontracts_1.GuardProto.toByteString(realState));
    const commitTx = new common_1.btc.Transaction()
        .from(feeutxo)
        .addOutput(new common_1.btc.Transaction.Output({
        satoshis: 0,
        script: (0, utils_1.toStateScript)(protocolState),
    }))
        .addOutput(new common_1.btc.Transaction.Output({
        satoshis: common_1.Postage.GUARD_POSTAGE,
        script: guardP2TR,
    }))
        .feePerByte(feeRate)
        .change(changeAddress);
    if (commitTx.getChangeOutput() === null) {
        throw new Error('Insufficient satoshis balance!');
    }
    commitTx.outputs[2].satoshis -= 1;
    if (ecKey.hasPrivateKey()) {
        ecKey.signTx(commitTx);
    }
    const contact = {
        utxo: {
            txId: commitTx.id,
            outputIndex: 1,
            script: commitTx.outputs[1].script.toHex(),
            satoshis: commitTx.outputs[1].satoshis,
        },
        state: {
            protocolState,
            data: realState,
        },
    };
    return {
        commitTx,
        contact,
        guardTapScript,
    };
}
exports.createGuardContract = createGuardContract;
async function unlockToken(ecKey, tokenContract, tokenInputIndex, prevTokenTx, preTokenInputIndex, prevPrevTokenTx, guardInfo, revealTx, minterP2TR, txCtx, verify, signature) {
    const { cblock: cblockToken, contract: token } = (0, utils_1.getTokenContractP2TR)(minterP2TR);
    const { shPreimage, prevoutsCtx, spentScripts, sighash } = txCtx;
    let sig;
    if (ecKey.hasPrivateKey()) {
        sig = common_1.btc.crypto.Schnorr.sign(ecKey.getTokenPrivateKey(), sighash.hash);
    }
    else {
        sig = common_1.btc.crypto.Signature.fromString(signature);
    }
    const pubkeyX = ecKey.getXOnlyPublicKey();
    const pubKeyPrefix = ecKey.getPubKeyPrefix();
    const tokenUnlockArgs = {
        isUserSpend: true,
        userPubKeyPrefix: pubKeyPrefix,
        userPubKey: (0, scrypt_ts_1.PubKey)(pubkeyX),
        userSig: sig.toString('hex'),
        contractInputIndex: 0n,
    };
    const backtraceInfo = (0, cat_smartcontracts_1.getBackTraceInfo)(prevTokenTx, prevPrevTokenTx, preTokenInputIndex);
    const { state: { protocolState, data: preState }, } = tokenContract;
    await token.connect((0, utils_1.getDummySigner)());
    const preTxState = {
        statesHashRoot: protocolState.hashRoot,
        txoStateHashes: protocolState.stateHashList,
    };
    const tokenCall = await token.methods.unlock(tokenUnlockArgs, preState, preTxState, guardInfo, backtraceInfo, shPreimage, prevoutsCtx, spentScripts, {
        fromUTXO: (0, utils_1.getDummyUTXO)(),
        verify: false,
        exec: false,
    });
    const witnesses = [
        ...(0, utils_1.callToBufferList)(tokenCall),
        token.lockingScript.toBuffer(),
        Buffer.from(cblockToken, 'hex'),
    ];
    revealTx.inputs[tokenInputIndex].witnesses = witnesses;
    if (verify) {
        const res = (0, utils_1.verifyContract)(tokenContract.utxo, revealTx, tokenInputIndex, witnesses);
        if (typeof res === 'string') {
            throw new Error(`unlocking token contract failed! ${res}`);
        }
        return true;
    }
    return true;
}
exports.unlockToken = unlockToken;
async function unlockGuard(guardContract, guardInfo, guardInputIndex, newState, revealTx, receiverTokenState, changeTokenState, changeInfo, txCtx, verify) {
    const { shPreimage, prevoutsCtx, spentScripts } = txCtx;
    const outputArray = (0, cat_smartcontracts_1.emptyTokenArray)();
    const tokenAmountArray = (0, cat_smartcontracts_1.emptyTokenAmountArray)();
    const tokenOutputIndexArray = (0, scrypt_ts_1.fill)(false, cat_smartcontracts_1.MAX_TOKEN_OUTPUT);
    outputArray[0] = receiverTokenState.ownerAddr;
    tokenAmountArray[0] = receiverTokenState.amount;
    tokenOutputIndexArray[0] = true;
    if (changeTokenState) {
        outputArray[1] = changeTokenState.ownerAddr;
        tokenAmountArray[1] = changeTokenState.amount;
        tokenOutputIndexArray[1] = true;
    }
    const satoshiChangeOutputIndex = changeTokenState === null ? 1 : 2;
    const { cblock: transferCblock, contract: transferGuard } = (0, utils_1.getGuardsP2TR)();
    await transferGuard.connect((0, utils_1.getDummySigner)());
    const outpointSatoshiArray = (0, cat_smartcontracts_1.emptyTokenArray)();
    outpointSatoshiArray[satoshiChangeOutputIndex] = changeInfo.satoshis;
    outputArray[satoshiChangeOutputIndex] = changeInfo.script;
    tokenOutputIndexArray[satoshiChangeOutputIndex] = false;
    const transferGuardCall = await transferGuard.methods.transfer(newState.stateHashList, outputArray, tokenAmountArray, tokenOutputIndexArray, outpointSatoshiArray, (0, scrypt_ts_1.int2ByteString)(BigInt(common_1.Postage.TOKEN_POSTAGE), 8n), guardContract.state.data, guardInfo.tx, shPreimage, prevoutsCtx, spentScripts, {
        fromUTXO: (0, utils_1.getDummyUTXO)(),
        verify: false,
        exec: false,
    });
    const witnesses = [
        ...(0, utils_1.callToBufferList)(transferGuardCall),
        transferGuard.lockingScript.toBuffer(),
        Buffer.from(transferCblock, 'hex'),
    ];
    revealTx.inputs[guardInputIndex].witnesses = witnesses;
    if (verify) {
        const res = (0, utils_1.verifyContract)(guardContract.utxo, revealTx, guardInputIndex, witnesses);
        if (typeof res === 'string') {
            throw new Error(`unlocking guard contract failed! ${res}`);
        }
        return true;
    }
    return true;
}
exports.unlockGuard = unlockGuard;
async function unlockGuardMulti(guardContract, guardInfo, guardInputIndex, newState, revealTx, tokenStates, tokenIndexes, txCtx, verify) {
    const { shPreimage, prevoutsCtx, spentScripts } = txCtx;
    const outputArray = (0, cat_smartcontracts_1.emptyTokenArray)();
    const tokenAmountArray = (0, cat_smartcontracts_1.emptyTokenAmountArray)();
    const tokenOutputIndexArray = (0, scrypt_ts_1.fill)(false, cat_smartcontracts_1.MAX_TOKEN_OUTPUT);
    const outpointSatoshiArray = (0, cat_smartcontracts_1.emptyTokenArray)();
    tokenStates.map((tokenState, i) => {
        const index = tokenIndexes[i];
        outputArray[index] = tokenState.ownerAddr;
        tokenAmountArray[index] = tokenState.amount;
        tokenOutputIndexArray[index] = true;
    });
    let nonTokenIndexes = Array.from({ length: revealTx.inputs.length }, (_, i) => i).filter(e => !tokenIndexes.includes(e));
    nonTokenIndexes.map((index) => {
        const input = revealTx.inputs[index];
        outpointSatoshiArray[index] = (0, scrypt_ts_1.int2ByteString)(BigInt(input.output.satoshis), 8n);
        outputArray[index] = (0, scrypt_ts_1.toByteString)(input.output.script.toHex());
    });
    const { cblock: transferCblock, contract: transferGuard } = (0, utils_1.getGuardsP2TR)();
    await transferGuard.connect((0, utils_1.getDummySigner)());
    const transferGuardCall = await transferGuard.methods.transfer(newState.stateHashList, outputArray, tokenAmountArray, tokenOutputIndexArray, outpointSatoshiArray, (0, scrypt_ts_1.int2ByteString)(BigInt(common_1.Postage.TOKEN_POSTAGE), 8n), guardContract.state.data, guardInfo.tx, shPreimage, prevoutsCtx, spentScripts, {
        fromUTXO: (0, utils_1.getDummyUTXO)(),
        verify: false,
        exec: false,
    });
    const witnesses = [
        ...(0, utils_1.callToBufferList)(transferGuardCall),
        transferGuard.lockingScript.toBuffer(),
        Buffer.from(transferCblock, 'hex'),
    ];
    revealTx.inputs[guardInputIndex].witnesses = witnesses;
    if (verify) {
        const res = (0, utils_1.verifyContract)(guardContract.utxo, revealTx, guardInputIndex, witnesses);
        if (typeof res === 'string') {
            throw new Error(`unlocking guard contract failed! ${res}`);
        }
        return true;
    }
    return true;
}
exports.unlockGuardMulti = unlockGuardMulti;
function createOpenMinterState(mintAmount, isPriemined, remainingSupply, metadata, newMinter) {
    const scaledInfo = (0, utils_1.scaleConfig)(metadata.info);
    const premine = !isPriemined ? scaledInfo.premine : 0n;
    const limit = scaledInfo.limit;
    let splitAmountList = cat_smartcontracts_1.OpenMinterProto.getSplitAmountList(premine + remainingSupply, mintAmount, limit, newMinter);
    if (metadata.info.minterMd5 == common_1.MinterType.OPEN_MINTER_V2) {
        splitAmountList = cat_smartcontracts_1.OpenMinterV2Proto.getSplitAmountList(remainingSupply, isPriemined, scaledInfo.premine);
        if (newMinter == 1) {
            splitAmountList[0] += splitAmountList[1];
            splitAmountList[1] = 0n;
        }
    }
    const tokenP2TR = (0, utils_1.toP2tr)(metadata.tokenAddr);
    const minterStates = [];
    for (let i = 0; i < splitAmountList.length; i++) {
        const amount = splitAmountList[i];
        if (amount > 0n) {
            const minterState = cat_smartcontracts_1.OpenMinterProto.create(tokenP2TR, true, amount);
            minterStates.push(minterState);
        }
    }
    return { splitAmountList, minterStates };
}
exports.createOpenMinterState = createOpenMinterState;
function pickOpenMinterStateField(state, key) {
    if (Object.prototype.hasOwnProperty.call(state, key)) {
        return state[key];
    }
    return undefined;
}
exports.pickOpenMinterStateField = pickOpenMinterStateField;
function getRemainSupply(state, minterMd5) {
    if (minterMd5 === common_1.MinterType.OPEN_MINTER_V1) {
        return pickOpenMinterStateField(state, 'remainingSupply');
    }
    else if (minterMd5 === common_1.MinterType.OPEN_MINTER_V2) {
        return pickOpenMinterStateField(state, 'remainingSupplyCount');
    }
}
exports.getRemainSupply = getRemainSupply;
function getPremineAddress(minterTx) {
    try {
        const tx = new common_1.btc.Transaction(minterTx);
        const witnesses = tx.inputs[0].getWitnesses();
        const lockingScript = witnesses[witnesses.length - 2];
        try {
            const minter = cat_smartcontracts_1.OpenMinterV2.fromLockingScript(lockingScript.toString('hex'));
            return minter.premineAddr;
        }
        catch (e) { }
        const minter = cat_smartcontracts_1.OpenMinter.fromLockingScript(lockingScript.toString('hex'));
        return minter.premineAddr;
    }
    catch (error) {
        throw error;
    }
}
exports.getPremineAddress = getPremineAddress;
//# sourceMappingURL=functions.js.map