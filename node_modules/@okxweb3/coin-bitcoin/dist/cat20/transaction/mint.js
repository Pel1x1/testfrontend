"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mint = void 0;
const utils_1 = require("../utils");
const common_1 = require("../common");
const cat_smartcontracts_1 = require("@cat-protocol/cat-smartcontracts");
const scrypt_ts_1 = require("scrypt-ts");
const functions_1 = require("./functions");
const decimal_js_1 = __importDefault(require("decimal.js"));
const MINTER_INPUT_INDEX = 0;
async function mint(param) {
    const ecKey = new utils_1.EcKeyService({ privateKey: param.privateKey });
    const txParams = param.data;
    let metadata = (0, utils_1.tokenInfoParse)(txParams.tokenMetadata, common_1.SupportedNetwork.fractalMainnet);
    const address = ecKey.getAddress();
    const tokenReceiver = ecKey.getTokenAddress();
    const tokenInfo = metadata.info;
    const scaledInfo = (0, utils_1.scaleConfig)(tokenInfo);
    const tokenP2TR = common_1.btc.Script.fromAddress(metadata.tokenAddr).toHex();
    const genesisId = (0, utils_1.outpoint2ByteString)(metadata.tokenId);
    const feeUtxos = (0, utils_1.feeUtxoParse)(ecKey, param.data.feeInputs);
    const { utxo: minterUtxo, state: { protocolState, data: preState }, } = (0, utils_1.minterParse)(txParams.minterContract, metadata, txParams.mintPrevTx.prevTx);
    let amount = BigInt(0);
    try {
        const d = new decimal_js_1.default(txParams.mintAmount).mul(Math.pow(10, scaledInfo.decimals));
        amount = BigInt(d.toString());
    }
    catch (error) {
        throw new Error(`Invalid token amount:  ${txParams.mintAmount}`);
    }
    const remainingSupply = (0, functions_1.getRemainSupply)(preState, scaledInfo.minterMd5);
    if (remainingSupply === undefined) {
        return new Error('Get remaining supply failed');
    }
    if ((0, common_1.isOpenMinter)(metadata.info.minterMd5)) {
        if (preState.isPremined && amount > scaledInfo.limit) {
            console.error('The number of minted tokens exceeds the limit!');
            return;
        }
        const limit = scaledInfo.limit;
        if (!preState.isPremined && scaledInfo.premine > 0n) {
            if (typeof amount === 'bigint') {
                if (amount !== scaledInfo.premine) {
                    throw new Error(`First mint amount should equal to premine ${scaledInfo.premine}`);
                }
            }
            else {
                amount = scaledInfo.premine;
            }
        }
        else {
            amount = amount || limit;
            if (metadata.info.minterMd5 === common_1.MinterType.OPEN_MINTER_V1 &&
                remainingSupply < amount) {
                throw new Error(`Remaining supply ${remainingSupply} is not enough to mint ${amount}`);
            }
            else if (tokenInfo.minterMd5 == common_1.MinterType.OPEN_MINTER_V2 &&
                amount != limit) {
                throw new Error(`V2 minters can only mint at the exactly amount of limit (${limit}) at once`);
            }
        }
    }
    const newState = cat_smartcontracts_1.ProtocolState.getEmptyState();
    const { splitAmountList, minterStates } = (0, functions_1.createOpenMinterState)(amount, preState.isPremined, remainingSupply, metadata, txParams.newMinter);
    for (let i = 0; i < minterStates.length; i++) {
        const minterState = minterStates[i];
        newState.updateDataList(i, cat_smartcontracts_1.OpenMinterProto.toByteString(minterState));
    }
    const tokenState = cat_smartcontracts_1.CAT20Proto.create(amount, tokenReceiver);
    newState.updateDataList(minterStates.length, cat_smartcontracts_1.CAT20Proto.toByteString(tokenState));
    let premineAddress = !preState.isPremined && scaledInfo.premine > 0n
        ? ecKey.getTokenAddress()
        : scaledInfo.premine === 0n
            ? ''
            : null;
    if (premineAddress === null) {
        premineAddress = (0, functions_1.getPremineAddress)(txParams.mintPrevTx.prevTx);
    }
    const { tapScript: minterTapScript, cblock: cblockToken, contract: minter, } = (0, utils_1.getOpenMinterContractP2TR)(genesisId, scaledInfo.max, scaledInfo.premine, scaledInfo.limit, premineAddress, tokenInfo.minterMd5);
    const changeScript = common_1.btc.Script.fromAddress(address);
    const revealTx = new common_1.btc.Transaction()
        .from([minterUtxo, ...feeUtxos])
        .addOutput(new common_1.btc.Transaction.Output({
        satoshis: 0,
        script: (0, utils_1.toStateScript)(newState),
    }));
    for (let i = 0; i < splitAmountList.length; i++) {
        if (splitAmountList[i] > 0n) {
            revealTx.addOutput(new common_1.btc.Transaction.Output({
                script: new common_1.btc.Script(minterUtxo.script),
                satoshis: common_1.Postage.MINTER_POSTAGE,
            }));
        }
    }
    revealTx
        .addOutput(new common_1.btc.Transaction.Output({
        satoshis: common_1.Postage.TOKEN_POSTAGE,
        script: tokenP2TR,
    }))
        .addOutput(new common_1.btc.Transaction.Output({
        satoshis: 0,
        script: changeScript,
    }))
        .feePerByte(txParams.feeRate);
    const commitTx = new common_1.btc.Transaction(txParams.mintPrevTx.prevTx);
    const prevPrevTxId = commitTx.inputs[MINTER_INPUT_INDEX].prevTxId.toString('hex');
    const prevPrevTx = new common_1.btc.Transaction(txParams.mintPrevTx.prevPrevTx);
    if (prevPrevTxId !== prevPrevTx.id) {
        return new Error('prevPrevTxId does not match');
    }
    const backtraceInfo = (0, cat_smartcontracts_1.getBackTraceInfo)(commitTx, prevPrevTx, MINTER_INPUT_INDEX);
    await minter.connect((0, utils_1.getDummySigner)());
    const preTxState = {
        statesHashRoot: protocolState.hashRoot,
        txoStateHashes: protocolState.stateHashList,
    };
    const vsize = await calcVsize(ecKey, minter, newState, tokenState, splitAmountList, preTxState, preState, minterTapScript, MINTER_INPUT_INDEX, revealTx, changeScript, backtraceInfo, cblockToken);
    const changeAmount = revealTx.inputAmount -
        vsize * txParams.feeRate -
        common_1.Postage.MINTER_POSTAGE * txParams.newMinter -
        common_1.Postage.TOKEN_POSTAGE;
    if (changeAmount < 546) {
        const message = 'Insufficient satoshis balance!';
        return new Error(message);
    }
    const changeOutputIndex = revealTx.outputs.length - 1;
    revealTx.outputs[changeOutputIndex].satoshis = changeAmount;
    const { shPreimage, prevoutsCtx, spentScripts, sighash } = (0, cat_smartcontracts_1.getTxCtx)(revealTx, MINTER_INPUT_INDEX, Buffer.from(minterTapScript, 'hex'));
    const changeInfo = {
        script: (0, scrypt_ts_1.toByteString)(changeScript.toHex()),
        satoshis: (0, scrypt_ts_1.int2ByteString)(BigInt(changeAmount), 8n),
    };
    const sig = common_1.btc.crypto.Schnorr.sign(ecKey.getTokenPrivateKey(), sighash.hash);
    const minterCall = await minter.methods.mint(newState.stateHashList, tokenState, splitAmountList, ecKey.getPubKeyPrefix(), ecKey.getXOnlyPublicKey(), () => sig.toString('hex'), (0, scrypt_ts_1.int2ByteString)(BigInt(common_1.Postage.MINTER_POSTAGE), 8n), (0, scrypt_ts_1.int2ByteString)(BigInt(common_1.Postage.TOKEN_POSTAGE), 8n), preState, preTxState, backtraceInfo, shPreimage, prevoutsCtx, spentScripts, changeInfo, {
        fromUTXO: (0, utils_1.getDummyUTXO)(),
        verify: false,
        exec: false,
    });
    const witnesses = [
        ...(0, utils_1.callToBufferList)(minterCall),
        minter.lockingScript.toBuffer(),
        Buffer.from(cblockToken, 'hex'),
    ];
    revealTx.inputs[MINTER_INPUT_INDEX].witnesses = witnesses;
    if (txParams.verifyScript) {
        const res = (0, utils_1.verifyContract)(minterUtxo, revealTx, MINTER_INPUT_INDEX, witnesses);
        if (typeof res === 'string') {
            console.log('unlocking minter failed:', res);
            return new Error('unlocking minter failed');
        }
    }
    ecKey.signTx(revealTx);
    console.log(revealTx.id);
    console.log(revealTx.getFee());
    return revealTx.uncheckedSerialize();
}
exports.mint = mint;
const calcVsize = async (ecKey, minter, newState, tokenMint, splitAmountList, preTxState, preState, minterTapScript, inputIndex, revealTx, changeScript, backtraceInfo, cblockMinter) => {
    const { shPreimage, prevoutsCtx, spentScripts, sighash } = (0, cat_smartcontracts_1.getTxCtx)(revealTx, inputIndex, Buffer.from(minterTapScript, 'hex'));
    const changeInfo = {
        script: (0, scrypt_ts_1.toByteString)(changeScript.toHex()),
        satoshis: (0, scrypt_ts_1.int2ByteString)(BigInt(0n), 8n),
    };
    const sig = common_1.btc.crypto.Schnorr.sign(ecKey.getTokenPrivateKey(), sighash.hash);
    const minterCall = await minter.methods.mint(newState.stateHashList, tokenMint, splitAmountList, ecKey.getPubKeyPrefix(), ecKey.getXOnlyPublicKey(), () => sig.toString('hex'), (0, scrypt_ts_1.int2ByteString)(BigInt(common_1.Postage.MINTER_POSTAGE), 8n), (0, scrypt_ts_1.int2ByteString)(BigInt(common_1.Postage.TOKEN_POSTAGE), 8n), preState, preTxState, backtraceInfo, shPreimage, prevoutsCtx, spentScripts, changeInfo, {
        fromUTXO: (0, utils_1.getDummyUTXO)(),
        verify: false,
        exec: false,
    });
    const witnesses = [
        ...(0, utils_1.callToBufferList)(minterCall),
        minter.lockingScript.toBuffer(),
        Buffer.from(cblockMinter, 'hex'),
    ];
    revealTx.inputs[inputIndex].witnesses = witnesses;
    ecKey.signTx(revealTx);
    const vsize = revealTx.vsize;
    (0, utils_1.resetTx)(revealTx);
    return vsize;
};
//# sourceMappingURL=mint.js.map