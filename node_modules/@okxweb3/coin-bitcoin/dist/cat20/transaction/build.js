"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = exports.tx2psbt = exports.UtxoType = void 0;
const common_1 = require("../common");
const utils_1 = require("../utils");
const functions_1 = require("./functions");
const cat_smartcontracts_1 = require("@cat-protocol/cat-smartcontracts");
const decimal_js_1 = __importDefault(require("decimal.js"));
const btcSigner = __importStar(require("@scure/btc-signer"));
const bitcoinjs = __importStar(require("../../bitcoinjs-lib"));
var UtxoType;
(function (UtxoType) {
    UtxoType["FEE"] = "fee";
    UtxoType["GUARD"] = "guard";
    UtxoType["TOKEN"] = "token";
    UtxoType["MINTER"] = "minter";
    UtxoType["SELL"] = "sell";
    UtxoType["CONTRACT"] = "contract";
    UtxoType["OP_RETURN"] = "op_return";
})(UtxoType = exports.UtxoType || (exports.UtxoType = {}));
function isTapScriptPsbtInfo(psbtInfo) {
    return !!psbtInfo && 'tapScript' in psbtInfo;
}
function isTapKeyPsbtInfo(psbtInfo) {
    return !!psbtInfo && 'tapInternalKey' in psbtInfo;
}
function tx2psbt(tx, psbtInfos) {
    const btcSignerTx = btcSigner.Transaction.fromRaw(tx.toBuffer(), { allowUnknownOutputs: true });
    const psbt = bitcoinjs.psbt.Psbt.fromBuffer(Buffer.from(btcSignerTx.toPSBT()));
    const toSignInputs = [];
    for (let i = 0; i < psbt.inputCount; i++) {
        const witnessUtxo = {
            value: tx.inputs[i].output.satoshis || 0n,
            script: tx.inputs[i].output.script.toBuffer() || common_1.btc.Script.empty(),
        };
        const psbtInfo = psbtInfos[i];
        if (isTapKeyPsbtInfo(psbtInfo)) {
            psbt.updateInput(i, {
                witnessUtxo,
                sighashType: 1,
            });
            toSignInputs.push({
                index: i,
                address: psbtInfo.address,
                sighashTypes: [1]
            });
        }
        else if (isTapScriptPsbtInfo(psbtInfo)) {
            psbt.updateInput(i, {
                witnessUtxo,
                tapLeafScript: [{
                        leafVersion: 192,
                        script: Buffer.from(psbtInfo.tapScript, 'hex'),
                        controlBlock: Buffer.from(psbtInfo.cblock, 'hex'),
                    }],
                sighashType: 1,
            });
            toSignInputs.push({
                index: i,
                address: psbtInfo.address,
                sighashTypes: [1],
            });
        }
        else {
            psbt.updateInput(i, {
                witnessUtxo,
                sighashType: 1,
            });
        }
    }
    return {
        psbt: psbt.toHex(),
        toSignInputs,
    };
}
exports.tx2psbt = tx2psbt;
function getTapKeySigFromPSBT(psbt, inputIndex) {
    const tapKeySig = psbt.data.inputs[inputIndex].tapKeySig;
    if (tapKeySig) {
        return Buffer.from(tapKeySig);
    }
    throw new Error(`getTapKeySigFromPSBT failed for input: ${inputIndex}`);
}
function getTapScriptSigFromPSBT(psbt, inputIndex) {
    const tapScriptSig = psbt.data.inputs[inputIndex].tapScriptSig;
    if (Array.isArray(tapScriptSig) && tapScriptSig.length >= 1) {
        return Buffer.from(tapScriptSig[0].signature);
    }
    throw new Error(`getTapScriptSigFromPSBT failed for input: ${inputIndex}`);
}
async function build(params) {
    const tx = new common_1.btc.Transaction();
    let verifyScript = params.verifyScript || false;
    const newState = cat_smartcontracts_1.ProtocolState.getEmptyState();
    let metadatas = params.tokenMetadatas.map(m => {
        const metadata = (0, utils_1.tokenInfoParse)(m, common_1.SupportedNetwork.fractalMainnet);
        const minterP2TR = (0, utils_1.toP2tr)(metadata.minterAddr);
        const { p2tr: tokenP2TR, tapScript: tokenTapScript, cblock: tokenCblock } = (0, utils_1.getTokenContractP2TR)(minterP2TR);
        const inputTokenAmountArray = new Array(cat_smartcontracts_1.MAX_INPUT).fill(0n);
        const tokenStates = [];
        const tokenIndexes = [];
        return {
            metadata,
            minterP2TR,
            tokenP2TR,
            tokenTapScript,
            tokenStates,
            tokenCblock,
            tokenIndexes,
            inputTokenAmountArray,
        };
    });
    const { p2tr: guardP2TR, tapScript: guardTapScript } = (0, utils_1.getGuardsP2TR)();
    let psbtInfos = [];
    const inputUtxos = params.inputs.map((input, i) => {
        let txInput = {
            txId: input.txId,
            outputIndex: input.vOut,
            script: input.script ?? '',
            satoshis: input.amount,
        };
        if (txInput.script) {
            return txInput;
        }
        let psbtInfo = undefined;
        if (input.type == UtxoType.FEE) {
            if (!input.address) {
                throw new Error(`Fee input requires either script or address`);
            }
            txInput.script = common_1.btc.Script.fromAddress(input.address);
            const ecKey = new utils_1.EcKeyService({ publicKey: input.publicKey });
            psbtInfo = {
                address: new common_1.btc.Address(input.address).toString(),
                tapInternalKey: ecKey.getXOnlyPublicKey(),
            };
            psbtInfos.push(psbtInfo);
        }
        else if (input.type == UtxoType.TOKEN) {
            if (!input.contractParams) {
                throw new Error(`Token input ${i} requires contractParams`);
            }
            const tokenParams = JSON.parse(input.contractParams);
            const metadataIndex = input.tokenMetadataIndex;
            if (metadataIndex === undefined) {
                throw new Error(`Token input ${i} requires tokenMetadataIndex`);
            }
            if (metadataIndex >= metadatas.length) {
                throw new Error(`Token input ${i} tokenMetadataIndex ${metadataIndex} out of metadatas' range ${metadatas.length}`);
            }
            const { tokenP2TR, tokenTapScript, tokenCblock } = metadatas[metadataIndex];
            txInput.script = tokenP2TR;
            psbtInfo = {
                address: (0, utils_1.p2tr2Address)(tokenP2TR, common_1.SupportedNetwork.fractalMainnet),
                tapScript: tokenTapScript,
                cblock: tokenCblock,
            };
            psbtInfos.push(psbtInfo);
            if (!params.signedResults) {
                return txInput;
            }
            const [token] = (0, utils_1.tokenUtxoParse)(tokenParams.tokenUtxo);
            metadatas[metadataIndex].inputTokenAmountArray[i] = token.state.data.amount;
            metadatas[metadataIndex].tokenIndexes.push(i);
            metadatas[metadataIndex].tokenStates.push(token.state.data);
        }
        else if (input.type == UtxoType.GUARD) {
            txInput.script = guardP2TR;
            psbtInfos.push(psbtInfo);
            if (!params.signedResults) {
                return txInput;
            }
            const metadataIndex = input.tokenMetadataIndex;
            if (metadataIndex === undefined) {
                throw new Error(`Token input ${i} requires tokenMetadataIndex`);
            }
            if (metadataIndex >= metadatas.length) {
                throw new Error(`Token input ${i} tokenMetadataIndex ${metadataIndex} out of metadatas' range ${metadatas.length}`);
            }
            const { tokenP2TR, inputTokenAmountArray } = metadatas[metadataIndex];
            const guardContract = {
                utxo: txInput,
                state: {
                    protocolState: cat_smartcontracts_1.ProtocolState.getEmptyState(),
                    data: {
                        tokenScript: tokenP2TR,
                        inputTokenAmountArray: inputTokenAmountArray,
                    }
                }
            };
            if (input.previousTxs === undefined) {
                throw new Error(`Guard input ${i} requires previousTxs.prevTx`);
            }
            const commitTx = new common_1.btc.Transaction(input.previousTxs.prevTx);
            const guardCommitTxHeader = (0, cat_smartcontracts_1.getTxHeaderCheck)(commitTx, guardContract.utxo.outputIndex);
            metadatas[metadataIndex].guardContract = guardContract;
            metadatas[metadataIndex].guardInfo = {
                outputIndex: (0, utils_1.toTxOutpoint)(guardContract.utxo.txId, guardContract.utxo.outputIndex).outputIndex,
                inputIndexVal: BigInt(i),
                tx: guardCommitTxHeader.tx,
                guardState: guardContract.state.data,
            };
        }
        else if (input.type == UtxoType.MINTER) {
            throw new Error('Minter currently not supported');
        }
        else if (input.type == UtxoType.SELL) {
            throw new Error('Sell currently not supported');
        }
        return txInput;
    });
    tx.from(inputUtxos);
    const outputs = params.outputs.map((output, i) => {
        let txOutput = {
            script: output.script,
            satoshis: output.amount,
        };
        if (txOutput.script) {
            return new common_1.btc.Transaction.Output(txOutput);
        }
        if (output.type == UtxoType.FEE) {
            txOutput.script = common_1.btc.Script.fromAddress(output.address);
        }
        else if (output.type == UtxoType.TOKEN) {
            if (!output.contractParams) {
                throw new Error(`Token output ${i} requires contractParams`);
            }
            const tokenParams = JSON.parse(output.contractParams);
            const metadataIndex = output.tokenMetadataIndex;
            if (metadataIndex === undefined) {
                throw new Error(`Token output ${i} requires tokenMetadataIndex`);
            }
            if (metadataIndex >= metadatas.length) {
                throw new Error(`Token output ${i} tokenMetadataIndex ${metadataIndex} out of metadatas' range ${metadatas.length}`);
            }
            const { metadata, tokenP2TR } = metadatas[metadataIndex];
            txOutput.script = tokenP2TR;
            let amount;
            try {
                const d = new decimal_js_1.default(tokenParams.tokenAmount).mul(Math.pow(10, metadata.info.decimals));
                amount = BigInt(d.toString());
            }
            catch (error) {
                throw new Error(`Invalid token amount:  ${tokenParams.tokenAmount}`);
            }
            const receiverTokenState = cat_smartcontracts_1.CAT20Proto.create(amount, (0, utils_1.toTokenAddress)(tokenParams.tokenReciever));
            newState.updateDataList(i, cat_smartcontracts_1.CAT20Proto.toByteString(receiverTokenState));
        }
        else if (output.type == UtxoType.GUARD) {
            txOutput.script = guardP2TR;
        }
        else if (output.type == UtxoType.MINTER) {
            throw new Error('Minter currently not supported');
        }
        else if (output.type == UtxoType.SELL) {
            throw new Error('Sell currently not supported');
        }
        return new common_1.btc.Transaction.Output(txOutput);
    });
    tx.addOutput(new common_1.btc.Transaction.Output({
        satoshis: 0,
        script: (0, utils_1.toStateScript)(newState),
    }));
    outputs.map(o => tx.addOutput(o));
    if (!params.signedResults) {
        return tx2psbt(tx, psbtInfos);
    }
    if (params.signedResults.signedPsbt === undefined) {
        throw new Error('signedPsbt is required');
    }
    const signedPsbt = bitcoinjs.psbt.Psbt.fromHex(params.signedResults.signedPsbt);
    await Promise.all(params.inputs.map(async (input, i) => {
        let txInput = {
            txId: input.txId,
            outputIndex: input.vOut,
            script: input.script,
            satoshis: input.amount,
        };
        if (txInput.script) {
            return txInput;
        }
        if (input.type == UtxoType.FEE) {
            const tapKeySig = getTapKeySigFromPSBT(signedPsbt, i);
            if (!tapKeySig) {
                throw new Error(`Token input ${i} requires tapKeySig in signedPsbt`);
            }
            tx.inputs[i].setWitnesses([
                tapKeySig,
            ]);
        }
        else if (input.type == UtxoType.TOKEN) {
            const tapScriptSig = getTapScriptSigFromPSBT(signedPsbt, i).toString('hex');
            if (!tapScriptSig) {
                throw new Error(`Token input ${i} requires tapScriptSig in signedPsbt`);
            }
            const metadataIndex = input.tokenMetadataIndex;
            if (metadataIndex === undefined) {
                throw new Error(`Token input ${i} requires tokenMetadataIndex`);
            }
            if (metadataIndex >= metadatas.length) {
                throw new Error(`Token input ${i} tokenMetadataIndex ${metadataIndex} out of metadatas' range ${metadatas.length}`);
            }
            const { metadata, minterP2TR, guardInfo, tokenTapScript } = metadatas[metadataIndex];
            if (guardInfo === undefined) {
                throw new Error(`Token ${i} has no matching guard`);
            }
            if (!input.previousTxs) {
                throw new Error(`Token ${i} requires previousTxs`);
            }
            if (!input.contractParams) {
                throw new Error(`Token input ${i} requires contractParams`);
            }
            const tokenParams = JSON.parse(input.contractParams);
            const [token] = (0, utils_1.tokenUtxoParse)(tokenParams.tokenUtxo);
            const tokenTx = (0, utils_1.validatePrevTx)(metadata, input.previousTxs.prevTx, input.previousTxs.prevPrevTx, common_1.SupportedNetwork.fractalMainnet);
            if (tokenTx === null) {
                throw new Error('prevTx does not match prevPrevTx');
            }
            const ecKey = new utils_1.EcKeyService({ publicKey: input.publicKey });
            const txCtx = (0, cat_smartcontracts_1.getTxCtx)(tx, i, Buffer.from(tokenTapScript, 'hex'));
            const res = await (0, functions_1.unlockToken)(ecKey, token, i, tokenTx.prevTx, tokenTx.prevTokenInputIndex, tokenTx.prevPrevTx, guardInfo, tx, minterP2TR, txCtx, verifyScript, tapScriptSig);
            if (!res) {
                throw new Error(`Building token input ${i} failed`);
            }
        }
        else if (input.type == UtxoType.GUARD) {
            txInput.script = guardP2TR;
            const metadataIndex = input.tokenMetadataIndex;
            if (metadataIndex === undefined) {
                throw new Error(`Token input ${i} requires tokenMetadataIndex`);
            }
            if (metadataIndex >= metadatas.length) {
                throw new Error(`Token input ${i} tokenMetadataIndex ${metadataIndex} out of metadatas' range ${metadatas.length}`);
            }
            const { guardContract, guardInfo, tokenIndexes, tokenStates } = metadatas[metadataIndex];
            if (guardInfo === undefined || guardContract == undefined) {
                throw new Error(`Guard ${i} has no guardInfo`);
            }
            const txCtx = (0, cat_smartcontracts_1.getTxCtx)(tx, i, Buffer.from(guardTapScript, 'hex'));
            const res = await (0, functions_1.unlockGuardMulti)(guardContract, guardInfo, i, newState, tx, tokenStates, tokenIndexes, txCtx, verifyScript);
            if (!res) {
                throw new Error(`Building guard input ${i} failed`);
            }
        }
        else if (input.type == UtxoType.MINTER) {
            throw new Error('Minter currently not supported');
        }
        else if (input.type == UtxoType.SELL) {
            throw new Error('Sell currently not supported');
        }
    }));
    return tx.uncheckedSerialize().toString('hex');
}
exports.build = build;
//# sourceMappingURL=build.js.map