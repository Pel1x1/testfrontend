"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUpper = exports.commitment = exports.Tag = exports.Flag = exports.base26Decode = exports.base26Encode = exports.decodeLEB128 = exports.encodeLEB128 = exports.removeSpacers = exports.getSpacersVal = exports.applySpacers = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
function applySpacers(str, spacers) {
    let res = '';
    for (let i = 0; i < str.length; i++) {
        res += str.charAt(i);
        if (spacers > 0) {
            let bit = spacers & 1;
            if (bit === 1) {
                res += '•';
            }
            spacers >>= 1;
        }
    }
    return res;
}
exports.applySpacers = applySpacers;
function getSpacersVal(str) {
    let res = 0;
    let spacersCnt = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charAt(i);
        if (char === '•' || char == '.') {
            res += 1 << (i - 1 - spacersCnt);
            spacersCnt++;
        }
    }
    return res;
}
exports.getSpacersVal = getSpacersVal;
function removeSpacers(rune) {
    return rune.replace(/[.•]+/g, "");
}
exports.removeSpacers = removeSpacers;
function encodeLEB128(value) {
    const bytes = [];
    let more = true;
    while (more) {
        let byte = Number(value & BigInt(0x7F));
        value >>= BigInt(7);
        if (value === BigInt(0)) {
            more = false;
        }
        else {
            byte |= 0x80;
        }
        bytes.push(byte);
    }
    return bytes;
}
exports.encodeLEB128 = encodeLEB128;
function decodeLEB128(buf) {
    let n = BigInt(0);
    for (let i = 0; i < buf.length; i++) {
        const byte = BigInt(buf[i]);
        if (i > 18) {
            throw new Error("Overlong");
        }
        let value = byte & BigInt(127);
        if ((i == 18) && ((value & BigInt(124)) != BigInt(0))) {
            throw new Error("Overflow");
        }
        n |= value << (BigInt(7) * BigInt(i));
        if ((byte & BigInt(128)) == BigInt(0)) {
            return {
                n,
                len: i + 1
            };
        }
    }
    throw new Error("Unterminated");
}
exports.decodeLEB128 = decodeLEB128;
function base26Encode(input) {
    let result = 0n;
    for (let i = 0; i < input.length; i++) {
        const charCode = BigInt(input.charCodeAt(i) - 'A'.charCodeAt(0));
        const iInv = BigInt(input.length) - 1n - BigInt(i);
        if (iInv == 0n) {
            result += charCode;
        }
        else {
            const base = 26n ** iInv;
            result += base * (charCode + 1n);
        }
    }
    return result;
}
exports.base26Encode = base26Encode;
function base26Decode(s) {
    if (s === 340282366920938463463374607431768211455n) {
        return "BCGDENLQRQWDSLRUGSNLBTMFIJAV";
    }
    s += 1n;
    let symbol = [];
    while (s > 0) {
        const i = (s - 1n) % 26n;
        symbol.push("ABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Number(i)));
        s = (s - 1n) / 26n;
    }
    return symbol.reverse().join('');
}
exports.base26Decode = base26Decode;
var Flag;
(function (Flag) {
    Flag[Flag["Etching"] = 0] = "Etching";
    Flag[Flag["Terms"] = 1] = "Terms";
    Flag[Flag["Turbo"] = 2] = "Turbo";
    Flag[Flag["Cenotaph"] = 127] = "Cenotaph";
})(Flag = exports.Flag || (exports.Flag = {}));
var Tag;
(function (Tag) {
    Tag[Tag["Body"] = 0] = "Body";
    Tag[Tag["Flags"] = 2] = "Flags";
    Tag[Tag["Rune"] = 4] = "Rune";
    Tag[Tag["Premine"] = 6] = "Premine";
    Tag[Tag["Cap"] = 8] = "Cap";
    Tag[Tag["Amount"] = 10] = "Amount";
    Tag[Tag["HeightStart"] = 12] = "HeightStart";
    Tag[Tag["HeightEnd"] = 14] = "HeightEnd";
    Tag[Tag["OffsetStart"] = 16] = "OffsetStart";
    Tag[Tag["OffsetEnd"] = 18] = "OffsetEnd";
    Tag[Tag["Mint"] = 20] = "Mint";
    Tag[Tag["Pointer"] = 22] = "Pointer";
    Tag[Tag["Cenotaph"] = 126] = "Cenotaph";
    Tag[Tag["Divisibility"] = 1] = "Divisibility";
    Tag[Tag["Spacers"] = 3] = "Spacers";
    Tag[Tag["Symbol"] = 5] = "Symbol";
    Tag[Tag["Nop"] = 127] = "Nop";
})(Tag = exports.Tag || (exports.Tag = {}));
function commitment(rune) {
    let runeValue;
    if (typeof rune.value === 'string') {
        let val = removeSpacers(rune.value);
        if (!isUpper(val)) {
            throw new Error("invalid rune");
        }
        runeValue = base26Encode(val);
    }
    else {
        runeValue = rune.value;
    }
    let nstr = runeValue.toString(16);
    if (nstr.length % 2 === 1) {
        nstr = '0' + nstr;
    }
    return crypto_lib_1.base.fromHex(nstr).reverse();
}
exports.commitment = commitment;
function isUpper(data) {
    return /^[A-Z]+$/.test(data);
}
exports.isUpper = isUpper;
//# sourceMappingURL=runestones.js.map