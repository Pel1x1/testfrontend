import { Buff } from '@cmdcode/buff';
import { _0n, _1n, _N } from '../const.js';
import { Field } from './ecc.js';
import { fd, invert, mod_n } from './math.js';
export function create_shares(secret, thold, total) {
    const coeffs = [Field.mod(secret).big];
    for (let i = 1; i < thold; i++) {
        const rand = Buff.random(32).big;
        coeffs.push(mod_n(rand));
    }
    const shares = [];
    for (let i = 1; i <= total; i++) {
        let result = _0n;
        coeffs.forEach((coeff, index) => {
            const idx = BigInt(i) ** BigInt(index);
            result += fd.mul(coeff, idx);
        });
        const index = Buff.num(i, 4);
        const value = Buff.big(result, 33);
        const share = Buff.join([index, value]);
        shares.push(share);
    }
    return shares;
}
export function combine_shares(shares) {
    const entries = shares.map(e => {
        const bytes = Buff.bytes(e);
        const index = bytes.subarray(0, 4).big;
        const value = bytes.subarray(4).big;
        return [index, value];
    });
    let secret = _0n;
    for (let i = 0; i < entries.length; i++) {
        let numer = _1n;
        let denom = _1n;
        for (let j = 0; j < entries.length; j++) {
            if (i !== j) {
                numer = (numer * -entries[j][0]) % _N;
                denom = (denom * (entries[i][0] - entries[j][0])) % _N;
            }
        }
        if (numer < _0n)
            numer += _N;
        if (denom < _0n)
            denom += _N;
        const coeff = (entries[i][1] * numer * invert(denom, _N)) % _N;
        secret = (secret + coeff) % _N;
    }
    return Buff.big(secret, 32);
}
//# sourceMappingURL=shamir.js.map