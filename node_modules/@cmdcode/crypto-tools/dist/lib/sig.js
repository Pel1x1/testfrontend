import { Buff } from '@cmdcode/buff';
import { _0n } from '../const.js';
import { Field, Point } from './ecc.js';
import { hash340 } from './hash.js';
import { get_pubkey, get_seckey } from './keys.js';
import * as assert from '../assert.js';
export function sign_msg(message, secret, options = {}) {
    const { adaptor, key_tweak } = options;
    const m = Buff.bytes(message);
    let dp = Field.mod(secret);
    if (key_tweak !== undefined) {
        dp = dp.negated.add(key_tweak);
    }
    const P = dp.point;
    const d = dp.negated;
    const n = gen_nonce(m, d, options);
    let kp = Field.mod(n);
    if (adaptor !== undefined) {
        kp = kp.negated.add(adaptor);
    }
    const R = kp.point;
    const k = kp.negated.big;
    const ch = hash340('BIP0340/challenge', R.x, P.x, m);
    const c = Field.mod(ch);
    const s = Field.mod(k + (c.big * d.big));
    return Buff.join([R.x, s.raw]);
}
export function verify_sig(signature, message, pubkey, options = {}) {
    const { throws = false } = options;
    const msg = Buff.bytes(message);
    const sig = Buff.bytes(signature);
    if (sig.length < 64) {
        return assert.fail('Signature length is too small: ' + String(sig.length), throws);
    }
    assert.size(pubkey, 32);
    const P = Point.from_x(pubkey);
    const rx = sig.subarray(0, 32);
    const R = Point.from_x(rx);
    const s = sig.subarray(32, 64);
    const sG = Field.mod(s).point;
    const ch = hash340('BIP0340/challenge', R.x, P.x, msg);
    const c = Field.mod(ch);
    const eP = P.mul(c.big);
    const r = sG.sub(eP);
    if (R.hasOddY) {
        return assert.fail('Signature R value has odd Y coordinate!', throws);
    }
    if (R.x.big === _0n) {
        return assert.fail('Signature R value is infinite!', throws);
    }
    if (R.x.big !== r.x.big) {
        return assert.fail(`Signature is invalid! R: ${R.x.hex} r:${r.x.hex}`, throws);
    }
    return R.x.big === r.x.big;
}
export function gen_nonce(message, secret, options = {}) {
    const { aux, nonce_seed, nonce_tweak, sec_nonce } = options;
    let nonce;
    if (nonce_seed !== undefined) {
        nonce = Buff.bytes(nonce_seed);
    }
    else {
        const seed = (aux === null) ? Buff.num(0, 32) : aux;
        const a = hash340('BIP0340/aux', seed ?? Buff.random(32));
        const t = Buff.bytes(secret).big ^ a.big;
        nonce = Buff.join([t, get_pubkey(secret, true)]);
    }
    let sn = (sec_nonce !== undefined)
        ? Field.mod(sec_nonce)
        : Field.mod(hash340('BIP0340/nonce', nonce, message));
    if (nonce_tweak !== undefined) {
        sn = sn.negated.add(nonce_tweak);
    }
    return sn.buff;
}
export function recover_key(message, pubkey, seed, signature) {
    const pub = Buff.bytes(pubkey);
    const sig = Buff.bytes(signature);
    const s_val = Field.mod(sig.slice(32, 64));
    const nonce = hash340('BIP0340/nonce', seed, message);
    const chal = hash340('BIP0340/challenge', sig.slice(0, 32), pub, message);
    const k = get_seckey(nonce, true);
    return s_val.sub(k).div(chal).buff;
}
//# sourceMappingURL=sig.js.map