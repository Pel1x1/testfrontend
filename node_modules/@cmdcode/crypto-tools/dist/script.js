var crypto_tools=function(t){"use strict";function e(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function n(t,...e){if(!((n=t)instanceof Uint8Array||null!=n&&"object"==typeof n&&"Uint8Array"===n.constructor.name))throw new Error("Expected Uint8Array");var n;if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function r(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");e(t.outputLen),e(t.blockLen)}function o(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const i="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function s(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}const f=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),c=(t,e)=>t<<32-e|t>>>e;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function a(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!s(t))throw new Error("expected Uint8Array, got "+typeof t);return t}class u{clone(){return this._cloneInto()}}const h={}.toString;function l(t){const e=e=>t().update(a(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function d(t=32){if(i&&"function"==typeof i.getRandomValues)return i.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class g extends u{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=f(this.buffer)}update(t){o(this);const{view:e,buffer:n,blockLen:r}=this,i=(t=a(t)).length;for(let o=0;o<i;){const s=Math.min(r-this.pos,i-o);if(s!==r)n.set(t.subarray(o,o+s),this.pos),this.pos+=s,o+=s,this.pos===r&&(this.process(e,0),this.pos=0);else{const e=f(t);for(;r<=i-o;o+=r)this.process(e,o)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){o(this),function(t,e){n(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:i,isLE:s}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>i-c&&(this.process(r,0),c=0);for(let t=c;t<i;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),f=Number(n&i),c=r?4:0,a=r?0:4;t.setUint32(e+c,s,r),t.setUint32(e+a,f,r)}(r,i-8,BigInt(8*this.length),s),this.process(r,0);const a=f(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=u/4,l=this.get();if(h>l.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<h;t++)a.setUint32(4*t,l[t],s)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:i,pos:s}=this;return t.length=r,t.pos=s,t.finished=o,t.destroyed=i,r%e&&t.buffer.set(n),t}}const y=(t,e,n)=>t&e^t&n^e&n,w=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),p=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),b=new Uint32Array(64);class m extends g{constructor(){super(64,32,8,!1),this.A=0|p[0],this.B=0|p[1],this.C=0|p[2],this.D=0|p[3],this.E=0|p[4],this.F=0|p[5],this.G=0|p[6],this.H=0|p[7]}get(){const{A:t,B:e,C:n,D:r,E:o,F:i,G:s,H:f}=this;return[t,e,n,r,o,i,s,f]}set(t,e,n,r,o,i,s,f){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|f}process(t,e){for(let n=0;n<16;n++,e+=4)b[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=b[t-15],n=b[t-2],r=c(e,7)^c(e,18)^e>>>3,o=c(n,17)^c(n,19)^n>>>10;b[t]=o+b[t-7]+r+b[t-16]|0}let{A:n,B:r,C:o,D:i,E:s,F:f,G:a,H:u}=this;for(let t=0;t<64;t++){const e=u+(c(s,6)^c(s,11)^c(s,25))+((h=s)&f^~h&a)+w[t]+b[t]|0,l=(c(n,2)^c(n,13)^c(n,22))+y(n,r,o)|0;u=a,a=f,f=s,s=i+e|0,i=o,o=r,r=n,n=e+l|0}var h;n=n+this.A|0,r=r+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,f=f+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(n,r,o,i,s,f,a,u)}roundClean(){b.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const x=l((()=>new m)),E=BigInt(0),v=BigInt(1),A=BigInt(2);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function B(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}const _=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function I(t){if(!B(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=_[t[n]];return e}function U(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function S(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const k={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function L(t){return t>=k._0&&t<=k._9?t-k._0:t>=k._A&&t<=k._F?t-(k._A-10):t>=k._a&&t<=k._f?t-(k._a-10):void 0}function $(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=L(t.charCodeAt(o)),i=L(t.charCodeAt(o+1));if(void 0===n||void 0===i){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+i}return r}function O(t){return S(I(t))}function T(t){if(!B(t))throw new Error("Uint8Array expected");return S(I(Uint8Array.from(t).reverse()))}function H(t,e){return $(t.toString(16).padStart(2*e,"0"))}function R(t,e){return H(t,e).reverse()}function j(t,e,n){let r;if("string"==typeof e)try{r=$(e)}catch(n){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${n}`)}else{if(!B(e))throw new Error(`${t} must be hex string or Uint8Array`);r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function N(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];if(!B(r))throw new Error("Uint8Array expected");e+=r.length}let n=new Uint8Array(e),r=0;for(let e=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}const z=t=>(A<<BigInt(t-1))-v,P=t=>new Uint8Array(t),q=t=>Uint8Array.from(t);function C(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=P(t),o=P(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},f=(...t)=>n(o,r,...t),c=(t=P())=>{o=f(q([0]),t),r=f(),0!==t.length&&(o=f(q([1]),t),r=f())},a=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){r=f();const e=r.slice();n.push(e),t+=r.length}return N(...n)};return(t,e)=>{let n;for(s(),c(t);!(n=e(a()));)c();return s(),n}}const F={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||B(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function D(t,e,n={}){const r=(e,n,r)=>{const o=F[n];if("function"!=typeof o)throw new Error(`Invalid validator "${n}", expected function`);const i=t[e];if(!(r&&void 0===i||o(i,t)))throw new Error(`Invalid param ${String(e)}=${i} (${typeof i}), expected ${n}`)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t}var V=Object.freeze({__proto__:null,bitGet:function(t,e){return t>>BigInt(e)&v},bitLen:function(t){let e;for(e=0;t>E;t>>=v,e+=1);return e},bitMask:z,bitSet:(t,e,n)=>t|(n?v:E)<<BigInt(e),bytesToHex:I,bytesToNumberBE:O,bytesToNumberLE:T,concatBytes:N,createHmacDrbg:C,ensureBytes:j,equalBytes:function(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n},hexToBytes:$,hexToNumber:S,isBytes:B,numberToBytesBE:H,numberToBytesLE:R,numberToHexUnpadded:U,numberToVarBytesBE:function(t){return $(U(t))},utf8ToBytes:function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))},validateObject:D});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const K=BigInt(0),G=BigInt(1),W=BigInt(2),Z=BigInt(3),Y=BigInt(4),M=BigInt(5),J=BigInt(8);function X(t,e){const n=t%e;return n>=K?n:e+n}function Q(t,e,n){if(n<=K||e<K)throw new Error("Expected power/modulo > 0");if(n===G)return K;let r=G;for(;e>K;)e&G&&(r=r*t%n),t=t*t%n,e>>=G;return r}function tt(t,e,n){let r=t;for(;e-- >K;)r*=r,r%=n;return r}function et(t,e){if(t===K||e<=K)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=X(t,e),r=e,o=K,i=G;for(;n!==K;){const t=r%n,e=o-i*(r/n);r=n,n=t,o=i,i=e}if(r!==G)throw new Error("invert: does not exist");return X(o,e)}function nt(t){if(t%Y===Z){const e=(t+G)/Y;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}if(t%J===M){const e=(t-M)/J;return function(t,n){const r=t.mul(n,W),o=t.pow(r,e),i=t.mul(n,o),s=t.mul(t.mul(i,W),o),f=t.mul(i,t.sub(s,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}}return function(t){const e=(t-G)/W;let n,r,o;for(n=t-G,r=0;n%W===K;n/=W,r++);for(o=W;o<t&&Q(o,e,t)!==t-G;o++);if(1===r){const e=(t+G)/Y;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}const i=(n+G)/W;return function(t,s){if(t.pow(s,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let f=r,c=t.pow(t.mul(t.ONE,o),n),a=t.pow(s,i),u=t.pow(s,n);for(;!t.eql(u,t.ONE);){if(t.eql(u,t.ZERO))return t.ZERO;let e=1;for(let n=t.sqr(u);e<f&&!t.eql(n,t.ONE);e++)n=t.sqr(n);const n=t.pow(c,G<<BigInt(f-e-1));c=t.sqr(n),a=t.mul(a,n),u=t.mul(u,c),f=e}return a}}(t)}BigInt(9),BigInt(16);const rt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ot(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function it(t,e,n=!1,r={}){if(t<=K)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:i}=ot(t,e);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=nt(t),f=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:z(o),ZERO:K,ONE:G,create:e=>X(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return K<=e&&e<t},is0:t=>t===K,isOdd:t=>(t&G)===G,neg:e=>X(-e,t),eql:(t,e)=>t===e,sqr:e=>X(e*e,t),add:(e,n)=>X(e+n,t),sub:(e,n)=>X(e-n,t),mul:(e,n)=>X(e*n,t),pow:(t,e)=>function(t,e,n){if(n<K)throw new Error("Expected power > 0");if(n===K)return t.ONE;if(n===G)return e;let r=t.ONE,o=e;for(;n>K;)n&G&&(r=t.mul(r,o)),o=t.sqr(o),n>>=G;return r}(f,t,e),div:(e,n)=>X(e*et(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>et(e,t),sqrt:r.sqrt||(t=>s(f,t)),invertBatch:t=>function(t,e){const n=new Array(e.length),r=e.reduce(((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r))),t.ONE),o=t.inv(r);return e.reduceRight(((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r))),o),n}(f,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>n?R(t,i):H(t,i),fromBytes:t=>{if(t.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${t.length}`);return n?T(t):O(t)}});return Object.freeze(f)}function st(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function ft(t){const e=st(t);return e+Math.ceil(e/2)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ct=BigInt(0),at=BigInt(1);function ut(t){return D(t.Fp,rt.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),D(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ot(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const{bytesToNumberBE:ht,hexToBytes:lt}=V,dt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=dt;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(128&r[0])throw new e("Invalid signature integer: negative");if(0===r[0]&&!(128&r[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:ht(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=dt,n="string"==typeof t?lt(t):t;if(!B(n))throw new Error("ui8a expected");let r=n.length;if(r<2||48!=n[0])throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:i}=dt._parseInt(n.subarray(2)),{d:s,l:f}=dt._parseInt(i);if(f.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:s}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,n=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},r=e(n(t.s)),o=e(n(t.r)),i=r.length/2,s=o.length/2,f=n(i),c=n(s);return`30${n(s+i+4)}02${c}${o}02${f}${r}`}},gt=BigInt(0),yt=BigInt(1);BigInt(2);const wt=BigInt(3);function pt(t){const e=function(t){const e=ut(t);D(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,r=e.toBytes||((t,e,r)=>{const o=e.toAffine();return N(Uint8Array.from([4]),n.toBytes(o.x),n.toBytes(o.y))}),o=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function i(t){const{a:r,b:o}=e,i=n.sqr(t),s=n.mul(i,t);return n.add(n.add(s,n.mul(t,r)),o)}if(!n.eql(n.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function s(t){return"bigint"==typeof t&&gt<t&&t<e.n}function f(t){if(!s(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:o,n:i}=e;if(n&&"bigint"!=typeof t){if(B(t)&&(t=I(t)),"string"!=typeof t||!n.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*r,"0")}let s;try{s="bigint"==typeof t?t:O(j("private key",t,r))}catch(e){throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof t}`)}return o&&(s=X(s,i)),f(s),s}const a=new Map;function u(t){if(!(t instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(t,e,r){if(this.px=t,this.py=e,this.pz=r,null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required")}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof h)throw new Error("projective point not allowed");const o=t=>n.eql(t,n.ZERO);return o(e)&&o(r)?h.ZERO:new h(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(h.fromAffine)}static fromHex(t){const e=h.fromAffine(o(j("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return h.BASE.multiply(c(t))}_setWindowSize(t){this._WINDOW_SIZE=t,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:r}=this.toAffine();if(!n.isValid(t)||!n.isValid(r))throw new Error("bad point: x or y not FE");const o=n.sqr(r),s=i(t);if(!n.eql(o,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){u(t);const{px:e,py:r,pz:o}=this,{px:i,py:s,pz:f}=t,c=n.eql(n.mul(e,f),n.mul(i,o)),a=n.eql(n.mul(r,f),n.mul(s,o));return c&&a}negate(){return new h(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,o=n.mul(r,wt),{px:i,py:s,pz:f}=this;let c=n.ZERO,a=n.ZERO,u=n.ZERO,l=n.mul(i,i),d=n.mul(s,s),g=n.mul(f,f),y=n.mul(i,s);return y=n.add(y,y),u=n.mul(i,f),u=n.add(u,u),c=n.mul(t,u),a=n.mul(o,g),a=n.add(c,a),c=n.sub(d,a),a=n.add(d,a),a=n.mul(c,a),c=n.mul(y,c),u=n.mul(o,u),g=n.mul(t,g),y=n.sub(l,g),y=n.mul(t,y),y=n.add(y,u),u=n.add(l,l),l=n.add(u,l),l=n.add(l,g),l=n.mul(l,y),a=n.add(a,l),g=n.mul(s,f),g=n.add(g,g),l=n.mul(g,y),c=n.sub(c,l),u=n.mul(g,d),u=n.add(u,u),u=n.add(u,u),new h(c,a,u)}add(t){u(t);const{px:r,py:o,pz:i}=this,{px:s,py:f,pz:c}=t;let a=n.ZERO,l=n.ZERO,d=n.ZERO;const g=e.a,y=n.mul(e.b,wt);let w=n.mul(r,s),p=n.mul(o,f),b=n.mul(i,c),m=n.add(r,o),x=n.add(s,f);m=n.mul(m,x),x=n.add(w,p),m=n.sub(m,x),x=n.add(r,i);let E=n.add(s,c);return x=n.mul(x,E),E=n.add(w,b),x=n.sub(x,E),E=n.add(o,i),a=n.add(f,c),E=n.mul(E,a),a=n.add(p,b),E=n.sub(E,a),d=n.mul(g,x),a=n.mul(y,b),d=n.add(a,d),a=n.sub(p,d),d=n.add(p,d),l=n.mul(a,d),p=n.add(w,w),p=n.add(p,w),b=n.mul(g,b),x=n.mul(y,x),p=n.add(p,b),b=n.sub(w,b),b=n.mul(g,b),x=n.add(x,b),w=n.mul(p,x),l=n.add(l,w),w=n.mul(E,x),a=n.mul(m,a),a=n.sub(a,w),w=n.mul(m,p),d=n.mul(E,d),d=n.add(d,w),new h(a,l,d)}subtract(t){return this.add(t.negate())}is0(){return this.equals(h.ZERO)}wNAF(t){return d.wNAFCached(this,a,t,(t=>{const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(h.fromAffine)}))}multiplyUnsafe(t){const r=h.ZERO;if(t===gt)return r;if(f(t),t===yt)return this;const{endo:o}=e;if(!o)return d.unsafeLadder(this,t);let{k1neg:i,k1:s,k2neg:c,k2:a}=o.splitScalar(t),u=r,l=r,g=this;for(;s>gt||a>gt;)s&yt&&(u=u.add(g)),a&yt&&(l=l.add(g)),g=g.double(),s>>=yt,a>>=yt;return i&&(u=u.negate()),c&&(l=l.negate()),l=new h(n.mul(l.px,o.beta),l.py,l.pz),u.add(l)}multiply(t){f(t);let r,o,i=t;const{endo:s}=e;if(s){const{k1neg:t,k1:e,k2neg:f,k2:c}=s.splitScalar(i);let{p:a,f:u}=this.wNAF(e),{p:l,f:g}=this.wNAF(c);a=d.constTimeNegate(t,a),l=d.constTimeNegate(f,l),l=new h(n.mul(l.px,s.beta),l.py,l.pz),r=a.add(l),o=u.add(g)}else{const{p:t,f:e}=this.wNAF(i);r=t,o=e}return h.normalizeZ([r,o])[0]}multiplyAndAddUnsafe(t,e,n){const r=h.BASE,o=(t,e)=>e!==gt&&e!==yt&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,n));return i.is0()?void 0:i}toAffine(t){const{px:e,py:r,pz:o}=this,i=this.is0();null==t&&(t=i?n.ONE:n.inv(o));const s=n.mul(e,t),f=n.mul(r,t),c=n.mul(o,t);if(i)return{x:n.ZERO,y:n.ZERO};if(!n.eql(c,n.ONE))throw new Error("invZ was invalid");return{x:s,y:f}}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===yt)return!0;if(n)return n(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===yt?this:n?n(h,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),r(h,this,t)}toHex(t=!0){return I(this.toRawBytes(t))}}h.BASE=new h(e.Gx,e.Gy,n.ONE),h.ZERO=new h(n.ZERO,n.ONE,n.ZERO);const l=e.nBitLength,d=function(t,e){const n=(t,e)=>{const n=e.negate();return t?n:e},r=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:n,unsafeLadder(e,n){let r=t.ZERO,o=e;for(;n>ct;)n&at&&(r=r.add(o)),o=o.double(),n>>=at;return r},precomputeWindow(t,e){const{windows:n,windowSize:o}=r(e),i=[];let s=t,f=s;for(let t=0;t<n;t++){f=s,i.push(f);for(let t=1;t<o;t++)f=f.add(s),i.push(f);s=f.double()}return i},wNAF(e,o,i){const{windows:s,windowSize:f}=r(e);let c=t.ZERO,a=t.BASE;const u=BigInt(2**e-1),h=2**e,l=BigInt(e);for(let t=0;t<s;t++){const e=t*f;let r=Number(i&u);i>>=l,r>f&&(r-=h,i+=at);const s=e,d=e+Math.abs(r)-1,g=t%2!=0,y=r<0;0===r?a=a.add(n(g,o[s])):c=c.add(n(y,o[d]))}return{p:c,f:a}},wNAFCached(t,e,n,r){const o=t._WINDOW_SIZE||1;let i=e.get(t);return i||(i=this.precomputeWindow(t,o),1!==o&&e.set(t,r(i))),this.wNAF(o,i,n)}}}(h,e.endo?Math.ceil(l/2):l);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:i,isWithinCurveOrder:s}}function bt(t){const e=function(t){const e=ut(t);return D(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:r}=e,o=n.BYTES+1,i=2*n.BYTES+1;function s(t){return X(t,r)}function f(t){return et(t,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:a,weierstrassEquation:u,isWithinCurveOrder:h}=pt({...e,toBytes(t,e,r){const o=e.toAffine(),i=n.toBytes(o.x),s=N;return r?s(Uint8Array.from([e.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,n.toBytes(o.y))},fromBytes(t){const e=t.length,r=t[0],s=t.subarray(1);if(e!==o||2!==r&&3!==r){if(e===i&&4===r){return{x:n.fromBytes(s.subarray(0,n.BYTES)),y:n.fromBytes(s.subarray(n.BYTES,2*n.BYTES))}}throw new Error(`Point of length ${e} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}{const t=O(s);if(!(gt<(f=t)&&f<n.ORDER))throw new Error("Point is not on curve");const e=u(t);let o=n.sqrt(e);return 1==(1&r)!==((o&yt)===yt)&&(o=n.neg(o)),{x:t,y:o}}var f}}),l=t=>I(H(t,e.nByteLength));function d(t){return t>r>>yt}const g=(t,e,n)=>O(t.slice(e,n));class y{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){const n=e.nByteLength;return t=j("compactSignature",t,2*n),new y(g(t,0,n),g(t,n,2*n))}static fromDER(t){const{r:e,s:n}=dt.toSig(j("DER",t));return new y(e,n)}assertValidity(){if(!h(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!h(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new y(this.r,this.s,t)}recoverPublicKey(t){const{r:r,s:o,recovery:i}=this,a=m(j("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const u=2===i||3===i?r+e.n:r;if(u>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=0==(1&i)?"02":"03",d=c.fromHex(h+l(u)),g=f(u),y=s(-a*g),w=s(o*g),p=c.BASE.multiplyAndAddUnsafe(d,y,w);if(!p)throw new Error("point at infinify");return p.assertValidity(),p}hasHighS(){return d(this.s)}normalizeS(){return this.hasHighS()?new y(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return $(this.toDERHex())}toDERHex(){return dt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return $(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const w={isValidPrivateKey(t){try{return a(t),!0}catch(t){return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const t=ft(e.n);return function(t,e,n=!1){const r=t.length,o=st(e),i=ft(e);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const s=X(n?O(t):T(t),e-G)+G;return n?R(s,o):H(s,o)}(e.randomBytes(t),e.n)},precompute:(t=8,e=c.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function p(t){const e=B(t),n="string"==typeof t,r=(e||n)&&t.length;return e?r===o||r===i:n?r===2*o||r===2*i:t instanceof c}const b=e.bits2int||function(t){const n=O(t),r=8*t.length-e.nBitLength;return r>0?n>>BigInt(r):n},m=e.bits2int_modN||function(t){return s(b(t))},x=z(e.nBitLength);function E(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(gt<=t&&t<x))throw new Error(`bigint expected < 2^${e.nBitLength}`);return H(t,e.nByteLength)}function v(t,r,o=A){if(["recovered","canonical"].some((t=>t in o)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:u}=e;let{lowS:l,prehash:g,extraEntropy:w}=o;null==l&&(l=!0),t=j("msgHash",t),g&&(t=j("prehashed msgHash",i(t)));const p=m(t),x=a(r),v=[E(x),E(p)];if(null!=w){const t=!0===w?u(n.BYTES):w;v.push(j("extraEntropy",t))}const B=N(...v),_=p;return{seed:B,k2sig:function(t){const e=b(t);if(!h(e))return;const n=f(e),r=c.BASE.multiply(e).toAffine(),o=s(r.x);if(o===gt)return;const i=s(n*s(_+o*x));if(i===gt)return;let a=(r.x===o?0:2)|Number(r.y&yt),u=i;return l&&d(i)&&(u=function(t){return d(t)?s(-t):t}(i),a^=1),new y(o,u,a)}}}const A={lowS:e.lowS,prehash:!1},_={lowS:e.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return c.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,n=!0){if(p(t))throw new Error("first arg must be private key");if(!p(e))throw new Error("second arg must be public key");return c.fromHex(e).multiply(a(t)).toRawBytes(n)},sign:function(t,n,r=A){const{seed:o,k2sig:i}=v(t,n,r),s=e;return C(s.hash.outputLen,s.nByteLength,s.hmac)(o,i)},verify:function(t,n,r,o=_){const i=t;if(n=j("msgHash",n),r=j("publicKey",r),"strict"in o)throw new Error("options.strict was renamed to lowS");const{lowS:a,prehash:u}=o;let h,l;try{if("string"==typeof i||B(i))try{h=y.fromDER(i)}catch(t){if(!(t instanceof dt.Err))throw t;h=y.fromCompact(i)}else{if("object"!=typeof i||"bigint"!=typeof i.r||"bigint"!=typeof i.s)throw new Error("PARSE");{const{r:t,s:e}=i;h=new y(t,e)}}l=c.fromHex(r)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(a&&h.hasHighS())return!1;u&&(n=e.hash(n));const{r:d,s:g}=h,w=m(n),p=f(g),b=s(w*p),x=s(d*p),E=c.BASE.multiplyAndAddUnsafe(l,b,x)?.toAffine();return!!E&&s(E.x)===d},ProjectivePoint:c,Signature:y,utils:w}}BigInt(4);class mt extends u{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,r(t);const n=a(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(n.length>o?t.create().update(n).digest():n);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),i.fill(0)}update(t){return o(this),this.iHash.update(t),this}digestInto(t){o(this),n(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=r,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const xt=(t,e,n)=>new mt(t,e).update(n).digest();
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Et(t){return{hash:t,hmac:(e,...n)=>xt(t,e,function(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];if(!s(r))throw new Error("Uint8Array expected");e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}(...n)),randomBytes:d}}xt.create=(t,e)=>new mt(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const vt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),At=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Bt=BigInt(1),_t=BigInt(2),It=(t,e)=>(t+e/_t)/e;function Ut(t){const e=vt,n=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),f=BigInt(44),c=BigInt(88),a=t*t*t%e,u=a*a*t%e,h=tt(u,n,e)*u%e,l=tt(h,n,e)*u%e,d=tt(l,_t,e)*a%e,g=tt(d,o,e)*d%e,y=tt(g,i,e)*g%e,w=tt(y,f,e)*y%e,p=tt(w,c,e)*w%e,b=tt(p,f,e)*y%e,m=tt(b,n,e)*u%e,x=tt(m,s,e)*g%e,E=tt(x,r,e)*a%e,v=tt(E,_t,e);if(!St.eql(St.sqr(v),t))throw new Error("Cannot find square root");return v}const St=it(vt,void 0,void 0,{sqrt:Ut}),kt=function(t,e){const n=e=>bt({...t,...Et(e)});return Object.freeze({...n(e),create:n})}({a:BigInt(0),b:BigInt(7),Fp:St,n:At,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=At,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Bt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,s=BigInt("0x100000000000000000000000000000000"),f=It(i*t,e),c=It(-r*t,e);let a=X(t-f*n-c*o,e),u=X(-f*r-c*i,e);const h=a>s,l=u>s;if(h&&(a=e-a),l&&(u=e-u),a>s||u>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:h,k1:a,k2neg:l,k2:u}}}},x),Lt=BigInt(0),$t=t=>"bigint"==typeof t&&Lt<t&&t<vt,Ot=t=>"bigint"==typeof t&&Lt<t&&t<At,Tt={};function Ht(t,...e){let n=Tt[t];if(void 0===n){const e=x(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=N(e,e),Tt[t]=n}return x(N(n,...e))}const Rt=t=>t.toRawBytes(!0).slice(1),jt=t=>H(t,32),Nt=t=>X(t,vt),zt=t=>X(t,At),Pt=kt.ProjectivePoint,qt=(t,e,n)=>Pt.BASE.multiplyAndAddUnsafe(t,e,n);function Ct(t){let e=kt.utils.normPrivateKeyToScalar(t),n=Pt.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:zt(-e),bytes:Rt(n)}}function Ft(t){if(!$t(t))throw new Error("bad x: need 0 < x < p");const e=Nt(t*t);let n=Ut(Nt(e*t+BigInt(7)));n%_t!==Lt&&(n=Nt(-n));const r=new Pt(t,n,Bt);return r.assertValidity(),r}function Dt(...t){return zt(O(Ht("BIP0340/challenge",...t)))}function Vt(t){return Ct(t).bytes}function Kt(t,e,n=d(32)){const r=j("message",t),{bytes:o,scalar:i}=Ct(e),s=j("auxRand",n,32),f=jt(i^O(Ht("BIP0340/aux",s))),c=Ht("BIP0340/nonce",f,o,r),a=zt(O(c));if(a===Lt)throw new Error("sign failed: k is zero");const{bytes:u,scalar:h}=Ct(a),l=Dt(u,o,r),g=new Uint8Array(64);if(g.set(u,0),g.set(jt(zt(h+l*i)),32),!Gt(g,r,o))throw new Error("sign: Invalid signature produced");return g}function Gt(t,e,n){const r=j("signature",t,64),o=j("message",e),i=j("publicKey",n,32);try{const t=Ft(O(i)),e=O(r.subarray(0,32));if(!$t(e))return!1;const n=O(r.subarray(32,64));if(!Ot(n))return!1;const s=Dt(jt(e),Rt(t),o),f=qt(t,n,zt(-s));return!(!f||!f.hasEvenY()||f.toAffine().x!==e)}catch(t){return!1}}const Wt=(()=>({getPublicKey:Vt,sign:Kt,verify:Gt,utils:{randomPrivateKey:kt.utils.randomPrivateKey,lift_x:Ft,pointToBytes:Rt,numberToBytesBE:H,bytesToNumberBE:O,taggedHash:Ht,mod:X}}))();function Zt(t){if(t>Number.MAX_SAFE_INTEGER)throw new TypeError("Number exceeds safe bounds!")}function Yt(t,e){if(t!==e)throw new TypeError(`Bech32 prefix does not match: ${t} !== ${e}`)}const Mt=new TextEncoder,Jt=new TextDecoder;function Xt(t){return Mt.encode(t)}function Qt(t){return Jt.decode(t)}function te(t,e){!function(t){if(null!==t.match(/[^a-fA-f0-9]/))throw new TypeError("Invalid characters in hex string: "+t);if(t.length%2!=0)throw new Error(`Length of hex string is invalid: ${t.length}`)}(t);const n=t.length/2;if(void 0===e&&(e=n),n>e)throw new TypeError(`Hex string is larger than array size: ${n} > ${e}`);return e}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function ee(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function ne(...t){const e=t=>t,n=(t,e)=>n=>t(e(n));return{encode:t.map((t=>t.encode)).reduceRight(n,e),decode:t.map((t=>t.decode)).reduce(n,e)}}function re(t){return{encode:e=>{if(!Array.isArray(e)||e.length&&"number"!=typeof e[0])throw new Error("alphabet.encode input should be an array of numbers");return e.map((e=>{if(e<0||e>=t.length)throw new Error(`Digit index outside alphabet: ${e} (alphabet: ${t.length})`);return t[e]}))},decode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("alphabet.decode input should be array of strings");return e.map((e=>{if("string"!=typeof e)throw new Error(`alphabet.decode: not string element=${e}`);const n=t.indexOf(e);if(-1===n)throw new Error(`Unknown letter: "${e}". Allowed: ${t}`);return n}))}}}function oe(t=""){if("string"!=typeof t)throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("join.encode input should be array of strings");for(let t of e)if("string"!=typeof t)throw new Error(`join.encode: non-string input=${t}`);return e.join(t)},decode:e=>{if("string"!=typeof e)throw new Error("join.decode input should be string");return e.split(t)}}}function ie(t,e,n){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(t))throw new Error("convertRadix: data should be array");if(!t.length)return[];let r=0;const o=[],i=Array.from(t);for(i.forEach((t=>{if(t<0||t>=e)throw new Error(`Wrong integer: ${t}`)}));;){let t=0,s=!0;for(let o=r;o<i.length;o++){const f=i[o],c=e*t+f;if(!Number.isSafeInteger(c)||e*t/e!==t||c-f!=e*t)throw new Error("convertRadix: carry overflow");t=c%n;const a=Math.floor(c/n);if(i[o]=a,!Number.isSafeInteger(a)||a*n+t!==c)throw new Error("convertRadix: carry overflow");s&&(a?s=!1:r=o)}if(o.push(t),s)break}for(let e=0;e<t.length-1&&0===t[e];e++)o.push(0);return o.reverse()}const se=(t,e)=>e?se(e,t%e):t,fe=(t,e)=>t+(e-se(t,e));function ce(t,e,n,r){if(!Array.isArray(t))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(fe(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${fe(e,n)}`);let o=0,i=0;const s=2**n-1,f=[];for(const r of t){if(r>=2**e)throw new Error(`convertRadix2: invalid data word=${r} from=${e}`);if(o=o<<e|r,i+e>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);for(i+=e;i>=n;i-=n)f.push((o>>i-n&s)>>>0);o&=2**i-1}if(o=o<<n-i&s,!r&&i>=e)throw new Error("Excess padding");if(!r&&o)throw new Error(`Non-zero padding: ${o}`);return r&&i>0&&f.push(o>>>0),f}function ae(t,e=!1){if(t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(fe(8,t)>32||fe(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!ee(n))throw new Error("radix2.encode input should be Uint8Array");return ce(Array.from(n),8,t,!e)},decode:n=>{if(!Array.isArray(n)||n.length&&"number"!=typeof n[0])throw new Error("radix2.decode input should be array of numbers");return Uint8Array.from(ce(n,t,8,e))}}}function ue(t){if("function"!=typeof t)throw new Error("unsafeWrapper fn should be function");return function(...e){try{return t.apply(null,e)}catch(t){}}}const he=ne(ae(6),re("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),function(t,e="="){if("string"!=typeof e)throw new Error("padding chr should be string");return{encode(n){if(!Array.isArray(n)||n.length&&"string"!=typeof n[0])throw new Error("padding.encode input should be array of strings");for(let t of n)if("string"!=typeof t)throw new Error(`padding.encode: non-string input=${t}`);for(;n.length*t%8;)n.push(e);return n},decode(n){if(!Array.isArray(n)||n.length&&"string"!=typeof n[0])throw new Error("padding.encode input should be array of strings");for(let t of n)if("string"!=typeof t)throw new Error(`padding.decode: non-string input=${t}`);let r=n.length;if(r*t%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;r>0&&n[r-1]===e;r--)if(!((r-1)*t%8))throw new Error("Invalid padding: string has too much padding");return n.slice(0,r)}}}(6),oe("")),le=ne(ae(6),re("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),oe("")),de=t=>{return ne((e=58,{encode:t=>{if(!ee(t))throw new Error("radix.encode input should be Uint8Array");return ie(Array.from(t),256,e)},decode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("radix.decode input should be array of numbers");return Uint8Array.from(ie(t,e,256))}}),re(t),oe(""));var e},ge=de("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),ye=t=>ne(function(t,e){if("function"!=typeof e)throw new Error("checksum fn should be function");return{encode(n){if(!ee(n))throw new Error("checksum.encode: input should be Uint8Array");const r=e(n).slice(0,t),o=new Uint8Array(n.length+t);return o.set(n),o.set(r,n.length),o},decode(n){if(!ee(n))throw new Error("checksum.decode: input should be Uint8Array");const r=n.slice(0,-t),o=e(r).slice(0,t),i=n.slice(-t);for(let e=0;e<t;e++)if(o[e]!==i[e])throw new Error("Invalid checksum");return r}}}(4,(e=>t(t(e)))),ge),we=ne(re("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),oe("")),pe=[996825010,642813549,513874426,1027748829,705979059];function be(t){const e=t>>25;let n=(33554431&t)<<5;for(let t=0;t<pe.length;t++)1==(e>>t&1)&&(n^=pe[t]);return n}function me(t,e,n=1){const r=t.length;let o=1;for(let e=0;e<r;e++){const n=t.charCodeAt(e);if(n<33||n>126)throw new Error(`Invalid prefix (${t})`);o=be(o)^n>>5}o=be(o);for(let e=0;e<r;e++)o=be(o)^31&t.charCodeAt(e);for(let t of e)o=be(o)^t;for(let t=0;t<6;t++)o=be(o);return o^=n,we.encode(ce([o%2**30],30,5,!1))}function xe(t){const e="bech32"===t?1:734539939,n=ae(5),r=n.decode,o=n.encode,i=ue(r);function s(t,n=90){if("string"!=typeof t)throw new Error("bech32.decode input should be string, not "+typeof t);if(t.length<8||!1!==n&&t.length>n)throw new TypeError(`Wrong string length: ${t.length} (${t}). Expected (8..${n})`);const r=t.toLowerCase();if(t!==r&&t!==t.toUpperCase())throw new Error("String must be lowercase or uppercase");const o=(t=r).lastIndexOf("1");if(0===o||-1===o)throw new Error('Letter "1" must be present between prefix and data only');const i=t.slice(0,o),s=t.slice(o+1);if(s.length<6)throw new Error("Data must be at least 6 characters long");const f=we.decode(s).slice(0,-6),c=me(i,f,e);if(!s.endsWith(c))throw new Error(`Invalid checksum in ${t}: expected "${c}"`);return{prefix:i,words:f}}return{encode:function(t,n,r=90){if("string"!=typeof t)throw new Error("bech32.encode prefix should be string, not "+typeof t);if(!Array.isArray(n)||n.length&&"number"!=typeof n[0])throw new Error("bech32.encode words should be array of numbers, not "+typeof n);const o=t.length+7+n.length;if(!1!==r&&o>r)throw new TypeError(`Length ${o} exceeds limit ${r}`);const i=t.toLowerCase(),s=me(i,n,e);return`${i}1${we.encode(n)}${s}`},decode:s,decodeToBytes:function(t){const{prefix:e,words:n}=s(t,!1);return{prefix:e,words:n,bytes:r(n)}},decodeUnsafe:ue(s),fromWords:r,fromWordsUnsafe:i,toWords:o}}const Ee=xe("bech32"),ve=xe("bech32m"),Ae=t=>ye(x).encode(t),Be=t=>ye(x).decode(t),_e=t=>he.encode(t),Ie=t=>he.decode(t),Ue=t=>le.encode(t),Se=t=>le.decode(t),ke={to_words:Ee.toWords,to_bytes:Ee.fromWords,encode:(t,e,n=!1)=>Ee.encode(t,e,n),decode:(t,e=!1)=>{const{prefix:n,words:r}=Ee.decode(t,e);return{prefix:n,words:r}}},Le={to_words:ve.toWords,to_bytes:ve.fromWords,encode:(t,e,n=!1)=>ve.encode(t,e,n),decode:(t,e=!1)=>{const{prefix:n,words:r}=ve.decode(t,e);return{prefix:n,words:r}}},$e=BigInt(0),Oe=BigInt(255),Te=BigInt(256);function He(t,e,n="be"){void 0===e&&(e=function(t){if(t<=0xffn)return 1;if(t<=0xffffn)return 2;if(t<=0xffffffffn)return 4;if(t<=0xffffffffffffffffn)return 8;if(t<=0xffffffffffffffffffffffffffffffffn)return 16;if(t<=0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)return 32;throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.")}(t));const r="le"===n,o=new ArrayBuffer(e),i=new DataView(o);let s=r?0:e-1;for(;t>$e;){const e=t&Oe,n=Number(e);r?i.setUint8(s++,n):i.setUint8(s--,n),t=(t-e)/Te}return new Uint8Array(o)}function Re(t,e,n="be"){void 0===e&&(e=function(t){if(t<=255)return 1;if(t<=65535)return 2;if(t<=4294967295)return 4;throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!")}(t));const r="le"===n,o=new ArrayBuffer(e),i=new DataView(o);let s=r?0:e-1;for(;t>0;){const e=255&t;r?i.setUint8(s++,t):i.setUint8(s--,t),t=(t-e)/256}return new Uint8Array(o)}function je(t){return null===t.match(/[^a-fA-F0-9]/)&&t.length%2==0}function Ne(t){return!("string"!=typeof t||!je(t))||("number"==typeof t||"bigint"==typeof t||t instanceof Uint8Array||!(!Array.isArray(t)||!t.every((t=>"number"==typeof t))))}function ze(t,e,n="be"){void 0===e&&(e=t.length),function(t,e){if(t.length>e)throw new TypeError(`Data is larger than array size: ${t.length} > ${e}`)}(t,e);const r=new Uint8Array(e).fill(0),o="be"===n?0:e-t.length;return r.set(t,o),r}function Pe(t){let e,n=0;const r=t.reduce(((t,e)=>t+e.length),0),o=new Uint8Array(r);for(e=0;e<t.length;e++){const r=t[e];o.set(r,n),n+=r.length}return o}function qe(t,e){return"bigint"==typeof e?`${e}n`:e}function Ce(t,e){return"string"==typeof e&&/^[0-9]+n$/.test(e)?BigInt(e.slice(0,-1)):e}function Fe(t,e,n){if(t instanceof ArrayBuffer)return new Uint8Array(t);if(t instanceof Uint8Array)return ze(t,e,n);if(Array.isArray(t)){return Pe(t.map((t=>Fe(t,e,n))))}if("string"==typeof t)return function(t,e,n="le"){e=te(t,e);const r="le"===n,o=new ArrayBuffer(e),i=new DataView(o);let s=r?0:e-1;for(let e=0;e<t.length;e+=2){const n=t.substring(e,e+2),o=parseInt(n,16);r?i.setUint8(s++,o):i.setUint8(s--,o)}return new Uint8Array(o)}(t,e,n);if("bigint"==typeof t)return He(t,e,n);if("number"==typeof t)return Re(t,e,n);if("boolean"==typeof t)return Uint8Array.of(t?1:0);throw new TypeError("Unsupported format:"+String(typeof t))}class De extends Uint8Array{static{this.num=Ve}static{this.big=Ge}static{this.bin=Ke}static{this.raw=We}static{this.str=Ze}static{this.hex=Ye}static{this.bytes=on}static{this.json=Me}static{this.base64=Je}static{this.b64url=Xe}static{this.bech32=Qe}static{this.bech32m=tn}static{this.b58chk=en}static{this.encode=Xt}static{this.decode=Qt}static{this.parse=nn}static{this.is_bytes=Ne}static{this.is_hex=je}static{this.is_equal=rn}static random(t=32){const e=d(t);return new De(e,t)}static now(t=4){const e=Math.floor(Date.now()/1e3);return new De(e,t)}constructor(t,e,n){if(t instanceof De&&void 0===e)return t;super(Fe(t,e,n))}get arr(){return[...this]}get num(){return this.to_num()}get big(){return this.to_big()}get str(){return this.to_str()}get hex(){return this.to_hex()}get raw(){return new Uint8Array(this)}get bin(){return this.to_bin()}get b58chk(){return this.to_b58chk()}get base64(){return this.to_base64()}get b64url(){return this.to_b64url()}get digest(){return this.to_hash()}get id(){return this.to_hash().hex}get stream(){return new sn(this)}to_num(t="be"){return function(t){let e=0;for(let n=t.length-1;n>=0;n--)e=256*e+t[n],Zt(e);return e}("be"===t?this.reverse():this)}to_big(t="be"){return function(t){let e=BigInt(0);for(let n=t.length-1;n>=0;n--)e=e*Te+BigInt(t[n]);return BigInt(e)}("be"===t?this.reverse():this)}to_bin(){return function(t){const e=new Array(8*t.length);let n=0;for(const r of t){if(r>255)throw new Error(`Invalid byte value: ${r}. Byte values must be between 0 and 255.`);for(let t=7;t>=0;t--,n++)e[n]=r>>t&1}return e.join("")}(this)}to_hash(){const t=x(this);return new De(t)}to_json(t){void 0===t&&(t=Ce);const e=Qt(this);return JSON.parse(e,t)}to_bech32(t,e){const{encode:n,to_words:r}=ke;return n(t,r(this),e)}to_bech32m(t,e){const{encode:n,to_words:r}=Le;return n(t,r(this),e)}to_str(){return Qt(this)}to_hex(){return function(t){let e="";for(let n=0;n<t.length;n++)e+=t[n].toString(16).padStart(2,"0");return e}(this)}to_bytes(){return new Uint8Array(this)}to_b58chk(){return Ae(this)}to_base64(){return _e(this)}to_b64url(){return Ue(this)}append(t){return De.join([this,De.bytes(t)])}equals(t){return on(t).hex===this.hex}prepend(t){return De.join([De.bytes(t),this])}reverse(){const t=new Uint8Array(this).reverse();return new De(t)}slice(t,e){const n=new Uint8Array(this).slice(t,e);return new De(n)}set(t,e){this.set(t,e)}subarray(t,e){const n=new Uint8Array(this).subarray(t,e);return new De(n)}write(t,e){const n=De.bytes(t);this.set(n,e)}add_varint(t){const e=De.calc_varint(this.length,t);return De.join([e,this])}toJSON(){return this.hex}toString(){return this.hex}static from(t){return new De(Uint8Array.from(t))}static of(...t){return new De(Uint8Array.of(...t))}static join(t){const e=Pe(t.map((t=>De.bytes(t))));return new De(e)}static sort(t,e){const n=t.map((t=>on(t,e).hex));return n.sort(),n.map((t=>De.hex(t,e)))}static calc_varint(t,e){if(t<253)return De.num(t,1);if(t<65536)return De.of(253,...De.num(t,2,e));if(t<4294967296)return De.of(254,...De.num(t,4,e));if(BigInt(t)<0x10000000000000000n)return De.of(255,...De.num(t,8,e));throw new Error(`Value is too large: ${t}`)}}function Ve(t,e,n){return new De(t,e,n)}function Ke(t,e,n){return new De(function(t){const e=t.split("").map(Number);if(e.length%8!=0)throw new Error(`Binary array is invalid length: ${t.length}`);const n=new Uint8Array(e.length/8);for(let t=0,r=0;t<e.length;t+=8,r++){let o=0;for(let n=0;n<8;n++)o|=e[t+n]<<7-n;n[r]=o}return n}(t),e,n)}function Ge(t,e,n){return new De(t,e,n)}function We(t,e,n){return new De(t,e,n)}function Ze(t,e,n){return new De(Xt(t),e,n)}function Ye(t,e,n){return new De(t,e,n)}function Me(t,e){void 0===e&&(e=qe);const n=JSON.stringify(t,e);return new De(Xt(n))}function Je(t){return new De(Ie(t))}function Xe(t){return new De(Se(t))}function Qe(t,e,n){const{decode:r,to_bytes:o}=ke,{prefix:i,words:s}=r(t,e),f=o(s);return"string"==typeof n&&Yt(i,n),new De(f)}function tn(t,e,n){const{decode:r,to_bytes:o}=Le,{prefix:i,words:s}=r(t,e),f=o(s);return"string"==typeof n&&Yt(i,n),new De(f)}function en(t){return new De(Be(t))}function nn(t,e,n){const r=function(t,e,n){const r=t.length,o=n/e;if(n%e!=0)throw new TypeError(`Invalid parameters: ${n} % ${e} !== 0`);if(r!==n)throw new TypeError(`Invalid data stream: ${r} !== ${n}`);if(r%e!=0)throw new TypeError(`Invalid data stream: ${r} % ${e} !== 0`);const i=new Array(o);for(let n=0;n<o;n++){const r=n*e;i[n]=t.subarray(r,r+e)}return i}(Fe(t),e,n);return r.map((t=>De.bytes(t)))}function rn(t,e){return new De(t).hex===new De(e).hex}function on(t,e,n){return new De(t,e,n)}class sn{constructor(t){this.data=De.bytes(t),this.size=this.data.length}peek(t){if(t>this.size)throw new Error(`Size greater than stream: ${t} > ${this.size}`);return new De(this.data.slice(0,t))}read(t){const e=this.peek(t);return this.data=this.data.slice(t),this.size=this.data.length,e}read_varint(t){const e=this.read(1).num;switch(!0){case e>=0&&e<253:return e;case 253===e:return this.read(2).to_num(t);case 254===e:return this.read(4).to_num(t);case 255===e:return this.read(8).to_num(t);default:throw new Error(`Varint is out of range: ${e}`)}}}const fn=kt.CURVE,cn=fn.n,an=fn.p,un={x:fn.Gx,y:fn.Gy},hn=BigInt(0),ln=BigInt(1),dn=BigInt(2),gn=BigInt(3),yn=BigInt(4);var wn=Object.freeze({__proto__:null,_0n:hn,_1n:ln,_2n:dn,_3n:gn,_4n:yn,_G:un,_N:cn,_P:an});const pn=kt.ProjectivePoint,bn=pn;function mn(t){return new pn(t.x,t.y,ln).hasEvenY()}function xn(t){const e=t;return"object"==typeof e&&null!==e&&"bigint"==typeof e.x&&"bigint"==typeof e.y}function En(t){if(!xn(t))return!1;const e=new pn(t.x,t.y,ln);try{return e.assertValidity(),!0}catch{return!1}}var vn=Object.freeze({__proto__:null,Noble:bn,add:function(t,e){if(null===t)return e;if(null===e)return t;const n=new pn(t.x,t.y,ln),r=new pn(e.x,e.y,ln);try{const t=n.add(r);return t.assertValidity(),{x:t.x,y:t.y}}catch{return null}},assert_valid:function(t){if(!En(t))throw new Error("ECC point is invalid: "+String(t))},eq:function(t,e){return null===t&&null===e||null!==t&&null!==e&&(t.x===e.x&&t.y===e.y)},gen:function(t){const e=De.bytes(t),n=pn.BASE.multiply(e.big);return n.assertValidity(),{x:n.x,y:n.y}},is_even:mn,is_point:xn,is_valid:En,lift_x:function(t,e=!1){let n=De.bytes(t);32===n.length&&(n=n.prepend(2)),e&&2!==n[0]&&(n[0]=2);const r=pn.fromHex(n.hex);return r.assertValidity(),{x:r.x,y:r.y}},mul:function(t,e){if(null===t)return null;try{const n=De.bytes(e),r=new pn(t.x,t.y,ln).multiply(n.big);return r.assertValidity(),{x:r.x,y:r.y}}catch{return null}},negate:function(t){const e=new pn(t.x,t.y,ln);try{const t=e.negate();return t.assertValidity(),{x:t.x,y:t.y}}catch{return null}},sub:function(t,e){if(null===t)return e;if(null===e)return t;const n=new pn(t.x,t.y,ln),r=new pn(e.x,e.y,ln);try{const t=n.subtract(r);return t.assertValidity(),{x:t.x,y:t.y}}catch{return null}},to_bytes:function(t){const e=De.big(t.x,32),n=mn(t)?2:3;return De.join([n,e])}});const An=it(cn,32,!0),Bn=it,_n=t=>X(t,cn),In=nt(cn),Un=nt(an);var Sn=Object.freeze({__proto__:null,GF:Bn,fd:An,in_field:t=>"bigint"==typeof t&&hn<t&&t<cn,invert:et,mod:X,mod_bytes:function(t){const e=De.bytes(t).big;return De.big(_n(e),32)},mod_n:_n,mod_p:t=>X(t,an),on_curve:t=>"bigint"==typeof t&&hn<t&&t<an,pow:Q,pow2:tt,pow_n:(t,e)=>Q(t,e,cn),pt:vn,sqrt_n:In,sqrt_p:Un});function kn(t,e=!1){if(!e)return!1;throw new Error(t)}function Ln(t,e,n){const r=De.bytes(t);return r.length===e||kn(`Invalid byte size: ${r.hex} !== ${e}`,n)}function $n(t,e){return"bigint"==typeof t&&hn<t&&t<an||kn("x value is not on the curve!",e),!0}function On(t,e){return"bigint"==typeof t&&hn<t&&t<cn||kn("x value is not in the field!",e),!0}function Tn(t,e){if(void 0===e){if(!t.startsWith("m"))throw new Error("You need to specify a chain-code for a non-root path.")}else if(32!==De.bytes(e).length)throw new Error("Chain code must be 32 bytes!")}function Hn(t){if(""!==t&&null===t.match(/^(m)?(\/)?(\w+'?\/)*\w+'?$/))throw new Error("Provided path string is invalid: "+t)}function Rn(t){if(t>2147483648)throw new TypeError("Index value must not exceed 31 bits.")}var jn=Object.freeze({__proto__:null,exists:function(t){if(void 0===t)throw new TypeError("Input is undefined!");if(null===t)throw new TypeError("Input is null!")},fail:kn,in_field:On,ok:function(t,e){if(!1===t)throw new Error(e??"Assertion failed!")},on_curve:$n,size:Ln,valid_chain:Tn,valid_derive_state:function(t,e){if(t&&!e)throw new Error("Cannot derive hardedened paths when is_private is false!")},valid_hash:function(t){if(null===t.match(/^[0-9a-fA-F]{64}$/))throw new Error("Provided hash string is invalid: "+t)},valid_index:Rn,valid_path:Hn,valid_pubkey:function(t){if(33!==De.bytes(t).length)throw new TypeError("Index value must not exceed 31 bits.")}});const Nn=kt.ProjectivePoint;class zn extends Uint8Array{static{this.N=cn}static add(t){return t.map((t=>zn.mod(t))).reduce(((t,e)=>t.add(e)))}static mod(t){return new zn(t)}static mul(t){return t.map((t=>zn.mod(t))).reduce(((t,e)=>t.mul(e)))}static is_valid(t,e){return On(De.bytes(t,32).big,e)}static random(){return zn.mod(De.random(32))}constructor(t){const e=_n(function(t){if(t instanceof zn)return t.big;if(t instanceof Pn)return t.x.big;if(t instanceof Uint8Array)return De.raw(t).big;if("string"==typeof t)return De.hex(t).big;if("number"==typeof t)return De.num(t).big;if("bigint"==typeof t)return BigInt(t);throw TypeError("Invalid input type:"+typeof t)}(t));zn.is_valid(e,!0),super(De.big(e,32),32)}get buff(){return new De(this)}get raw(){return this.buff.raw}get big(){return this.buff.big}get hex(){return this.buff.hex}get point(){return this.generate()}get hasOddY(){return this.point.hasOddY}get negated(){return this.hasOddY?this.negate():this}gt(t){return new zn(t).big>this.big}lt(t){return new zn(t).big<this.big}eq(t){return new zn(t).big===this.big}ne(t){return new zn(t).big!==this.big}add(t){const e=zn.mod(t),n=An.add(this.big,e.big);return new zn(n)}sub(t){const e=zn.mod(t),n=An.sub(this.big,e.big);return new zn(n)}mul(t){const e=zn.mod(t),n=An.mul(this.big,e.big);return new zn(n)}pow(t){const e=zn.mod(t),n=An.pow(this.big,e.big);return new zn(n)}div(t){const e=zn.mod(t),n=An.div(this.big,e.big);return new zn(n)}negate(){return new zn(zn.N-this.big)}generate(){const t=kt.ProjectivePoint.BASE.multiply(this.big);return Pn.import(t)}}class Pn{static{this.P=an}static{this.G=new Pn(un.x,un.y)}static{this.curve=kt.CURVE}static{this.base=kt.ProjectivePoint.BASE}static from_x(t,e=!1){let n=function(t){if(t instanceof zn)return t.point.buff;if(t instanceof Pn)return t.buff;if(t instanceof Uint8Array||"string"==typeof t)return De.bytes(t);if("number"==typeof t||"bigint"==typeof t)return De.bytes(t,32);throw new TypeError("Unknown type: "+typeof t)}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */(t);32===n.length?n=n.prepend(2):e&&(n[0]=2),Ln(n,33);const r=Nn.fromHex(n.hex);return r.assertValidity(),new Pn(r.x,r.y)}static generate(t){const e=zn.mod(t),n=Pn.base.multiply(e.big);return Pn.import(n)}static{this.mul=Pn.generate}static import(t){const e=t instanceof Pn?{x:t.x.big,y:t.y.big}:{x:t.x,y:t.y};return new Pn(e.x,e.y)}constructor(t,e){this._p=new Nn(t,e,1n),this.p.assertValidity()}get p(){return this._p}get x(){return De.big(this.p.x,32)}get y(){return De.big(this.p.y,32)}get buff(){return De.raw(this.p.toRawBytes(!0))}get raw(){return this.buff.raw}get hex(){return this.buff.hex}get hasEvenY(){return this.p.hasEvenY()}get hasOddY(){return!this.p.hasEvenY()}get negated(){return this.hasOddY?this.negate():this}eq(t){const e=t instanceof Pn?t:Pn.from_x(t);return this.x.big===e.x.big&&this.y.big===e.y.big}add(t){return t instanceof Pn?Pn.import(this.p.add(t.p)):Pn.import(this.p.add(Pn.generate(t).p))}sub(t){return t instanceof Pn?Pn.import(this.p.subtract(t.p)):Pn.import(this.p.subtract(Pn.generate(t).p))}mul(t){return t instanceof Pn?Pn.import(this.p.multiply(t.x.big)):Pn.import(this.p.multiply(zn.mod(t).big))}negate(){return Pn.import(this.p.negate())}}const qn=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),Cn=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4));function Fn(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}const Dn=t=>new DataView(t.buffer,t.byteOffset,t.byteLength);if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function Vn(t){if("string"==typeof t)t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t);else{if(!Fn(t))throw new Error("expected Uint8Array, got "+typeof t);t=t.slice()}return t}function Kn(t,e){if(!Fn(t))throw new Error("Uint8Array expected");if("number"==typeof e&&t.length!==e)throw new Error(`Uint8Array length ${e} expected`)}function Gn(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n}const Wn=(t,e)=>(Object.assign(e,t),e);function Zn(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),f=Number(n&i),c=r?4:0,a=r?0:4;t.setUint32(e+c,s,r),t.setUint32(e+a,f,r)}function Yn(t,...e){if(null==(n=t)||"object"!=typeof n||!(n instanceof Uint8Array||"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function Mn(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Jn(t,e){Yn(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const Xn=16,Qn=new Uint8Array(16),tr=Cn(Qn),er=t=>(t>>>0&255)<<24|(t>>>8&255)<<16|(t>>>16&255)<<8|t>>>24&255|0;class nr{constructor(t,e){this.blockLen=Xn,this.outputLen=Xn,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,Kn(t=Vn(t),16);const n=Dn(t);let r=n.getUint32(0,!1),o=n.getUint32(4,!1),i=n.getUint32(8,!1),s=n.getUint32(12,!1);const f=[];for(let t=0;t<128;t++)f.push({s0:er(r),s1:er(o),s2:er(i),s3:er(s)}),({s0:r,s1:o,s2:i,s3:s}={s3:(u=i)<<31|(h=s)>>>1,s2:(a=o)<<31|u>>>1,s1:(c=r)<<31|a>>>1,s0:c>>>1^225<<24&-(1&h)});var c,a,u,h;const l=(t=>t>65536?8:t>1024?4:2)(e||1024);if(![1,2,4,8].includes(l))throw new Error(`ghash: wrong window size=${l}, should be 2, 4 or 8`);this.W=l;const d=128/l,g=this.windowSize=2**l,y=[];for(let t=0;t<d;t++)for(let e=0;e<g;e++){let n=0,r=0,o=0,i=0;for(let s=0;s<l;s++){if(!(e>>>l-s-1&1))continue;const{s0:c,s1:a,s2:u,s3:h}=f[l*t+s];n^=c,r^=a,o^=u,i^=h}y.push({s0:n,s1:r,s2:o,s3:i})}this.t=y}_updateBlock(t,e,n,r){t^=this.s0,e^=this.s1,n^=this.s2,r^=this.s3;const{W:o,t:i,windowSize:s}=this;let f=0,c=0,a=0,u=0;const h=(1<<o)-1;let l=0;for(const d of[t,e,n,r])for(let t=0;t<4;t++){const e=d>>>8*t&255;for(let t=8/o-1;t>=0;t--){const n=e>>>o*t&h,{s0:r,s1:d,s2:g,s3:y}=i[l*s+n];f^=r,c^=d,a^=g,u^=y,l+=1}}this.s0=f,this.s1=c,this.s2=a,this.s3=u}update(t){t=Vn(t),Mn(this);const e=Cn(t),n=Math.floor(t.length/Xn),r=t.length%Xn;for(let t=0;t<n;t++)this._updateBlock(e[4*t+0],e[4*t+1],e[4*t+2],e[4*t+3]);return r&&(Qn.set(t.subarray(n*Xn)),this._updateBlock(tr[0],tr[1],tr[2],tr[3]),tr.fill(0)),this}destroy(){const{t:t}=this;for(const e of t)e.s0=0,e.s1=0,e.s2=0,e.s3=0}digestInto(t){Mn(this),Jn(t,this),this.finished=!0;const{s0:e,s1:n,s2:r,s3:o}=this,i=Cn(t);return i[0]=e,i[1]=n,i[2]=r,i[3]=o,t}digest(){const t=new Uint8Array(Xn);return this.digestInto(t),this.destroy(),t}}class rr extends nr{constructor(t,e){const n=function(t){t.reverse();const e=1&t[15];let n=0;for(let e=0;e<t.length;e++){const r=t[e];t[e]=r>>>1|n,n=(1&r)<<7}return t[0]^=225&-e,t}((t=Vn(t)).slice());super(n,e),n.fill(0)}update(t){t=Vn(t),Mn(this);const e=Cn(t),n=t.length%Xn,r=Math.floor(t.length/Xn);for(let t=0;t<r;t++)this._updateBlock(er(e[4*t+3]),er(e[4*t+2]),er(e[4*t+1]),er(e[4*t+0]));return n&&(Qn.set(t.subarray(r*Xn)),this._updateBlock(er(tr[3]),er(tr[2]),er(tr[1]),er(tr[0])),tr.fill(0)),this}digestInto(t){Mn(this),Jn(t,this),this.finished=!0;const{s0:e,s1:n,s2:r,s3:o}=this,i=Cn(t);return i[0]=e,i[1]=n,i[2]=r,i[3]=o,t.reverse()}}function or(t){const e=(e,n)=>t(n,e.length).update(Vn(e)).digest(),n=t(new Uint8Array(16),0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=(e,n)=>t(e,n),e}const ir=or(((t,e)=>new nr(t,e))),sr=or(((t,e)=>new rr(t,e))),fr=16,cr=new Uint8Array(fr),ar=283;function ur(t){return t<<1^ar&-(t>>7)}function hr(t,e){let n=0;for(;e>0;e>>=1)n^=t&-(1&e),t=ur(t);return n}const lr=(()=>{let t=new Uint8Array(256);for(let e=0,n=1;e<256;e++,n^=ur(n))t[e]=n;const e=new Uint8Array(256);e[0]=99;for(let n=0;n<255;n++){let r=t[255-n];r|=r<<8,e[t[n]]=255&(r^r>>4^r>>5^r>>6^r>>7^99)}return e})(),dr=lr.map(((t,e)=>lr.indexOf(e))),gr=t=>t<<24|t>>>8,yr=t=>t<<8|t>>>24;function wr(t,e){if(256!==t.length)throw new Error("Wrong sbox length");const n=new Uint32Array(256).map(((n,r)=>e(t[r]))),r=n.map(yr),o=r.map(yr),i=o.map(yr),s=new Uint32Array(65536),f=new Uint32Array(65536),c=new Uint16Array(65536);for(let e=0;e<256;e++)for(let a=0;a<256;a++){const u=256*e+a;s[u]=n[e]^r[a],f[u]=o[e]^i[a],c[u]=t[e]<<8|t[a]}return{sbox:t,sbox2:c,T0:n,T1:r,T2:o,T3:i,T01:s,T23:f}}const pr=wr(lr,(t=>hr(t,3)<<24|t<<16|t<<8|hr(t,2))),br=wr(dr,(t=>hr(t,11)<<24|hr(t,13)<<16|hr(t,9)<<8|hr(t,14))),mr=(()=>{const t=new Uint8Array(16);for(let e=0,n=1;e<16;e++,n=ur(n))t[e]=n;return t})();function xr(t){Kn(t);const e=t.length;if(![16,24,32].includes(e))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${e}`);const{sbox2:n}=pr,r=Cn(t),o=r.length,i=t=>Ar(n,t,t,t,t),s=new Uint32Array(e+28);s.set(r);for(let t=o;t<s.length;t++){let e=s[t-1];t%o==0?e=i(gr(e))^mr[t/o-1]:o>6&&t%o==4&&(e=i(e)),s[t]=s[t-o]^e}return s}function Er(t){const e=xr(t),n=e.slice(),r=e.length,{sbox2:o}=pr,{T0:i,T1:s,T2:f,T3:c}=br;for(let t=0;t<r;t+=4)for(let o=0;o<4;o++)n[t+o]=e[r-t-4+o];e.fill(0);for(let t=4;t<r-4;t++){const e=n[t],r=Ar(o,e,e,e,e);n[t]=i[255&r]^s[r>>>8&255]^f[r>>>16&255]^c[r>>>24]}return n}function vr(t,e,n,r,o,i){return t[n<<8&65280|r>>>8&255]^e[o>>>8&65280|i>>>24&255]}function Ar(t,e,n,r,o){return t[255&e|65280&n]|t[r>>>16&255|o>>>16&65280]<<16}function Br(t,e,n,r,o){const{sbox2:i,T01:s,T23:f}=pr;let c=0;e^=t[c++],n^=t[c++],r^=t[c++],o^=t[c++];const a=t.length/4-2;for(let i=0;i<a;i++){const i=t[c++]^vr(s,f,e,n,r,o),a=t[c++]^vr(s,f,n,r,o,e),u=t[c++]^vr(s,f,r,o,e,n),h=t[c++]^vr(s,f,o,e,n,r);e=i,n=a,r=u,o=h}return{s0:t[c++]^Ar(i,e,n,r,o),s1:t[c++]^Ar(i,n,r,o,e),s2:t[c++]^Ar(i,r,o,e,n),s3:t[c++]^Ar(i,o,e,n,r)}}function _r(t,e,n,r,o){const{sbox2:i,T01:s,T23:f}=br;let c=0;e^=t[c++],n^=t[c++],r^=t[c++],o^=t[c++];const a=t.length/4-2;for(let i=0;i<a;i++){const i=t[c++]^vr(s,f,e,o,r,n),a=t[c++]^vr(s,f,n,e,o,r),u=t[c++]^vr(s,f,r,n,e,o),h=t[c++]^vr(s,f,o,r,n,e);e=i,n=a,r=u,o=h}return{s0:t[c++]^Ar(i,e,o,r,n),s1:t[c++]^Ar(i,n,e,o,r),s2:t[c++]^Ar(i,r,n,e,o),s3:t[c++]^Ar(i,o,r,n,e)}}function Ir(t,e){if(!e)return new Uint8Array(t);if(Kn(e),e.length<t)throw new Error(`aes: wrong destination length, expected at least ${t}, got: ${e.length}`);return e}function Ur(t,e,n,r,o){Kn(n,fr),Kn(r),o=Ir(r.length,o);const i=n,s=Cn(i),f=Dn(i),c=Cn(r),a=Cn(o),u=e?0:12,h=r.length;let l=f.getUint32(u,e),{s0:d,s1:g,s2:y,s3:w}=Br(t,s[0],s[1],s[2],s[3]);for(let n=0;n+4<=c.length;n+=4)a[n+0]=c[n+0]^d,a[n+1]=c[n+1]^g,a[n+2]=c[n+2]^y,a[n+3]=c[n+3]^w,l=l+1>>>0,f.setUint32(u,l,e),({s0:d,s1:g,s2:y,s3:w}=Br(t,s[0],s[1],s[2],s[3]));const p=fr*Math.floor(c.length/4);if(p<h){const t=new Uint32Array([d,g,y,w]),e=qn(t);for(let t=p,n=0;t<h;t++,n++)o[t]=r[t]^e[n]}return o}function Sr(t){if(Kn(t),t.length%fr!=0)throw new Error("aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16")}function kr(t,e,n){let r=t.length;const o=r%fr;if(!e&&0!==o)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const i=Cn(t);if(e){let t=fr-o;t||(t=fr),r+=t}const s=Ir(r,n);return{b:i,o:Cn(s),out:s}}function Lr(t,e){if(!e)return t;const n=t.length;if(!n)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=t[n-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const o=t.subarray(0,-r);for(let e=0;e<r;e++)if(t[n-e-1]!==r)throw new Error("aes/pcks5: wrong padding");return o}function $r(t){const e=new Uint8Array(16),n=Cn(e);e.set(t);const r=fr-t.length;for(let t=fr-r;t<fr;t++)e[t]=r;return n}Wn({blockSize:16,nonceLength:16},(function(t,e){function n(n,r){const o=xr(t),i=e.slice(),s=function(t,e,n,r){Kn(e,fr),Kn(n);const o=n.length;r=Ir(o,r);const i=e,s=Cn(i);let{s0:f,s1:c,s2:a,s3:u}=Br(t,s[0],s[1],s[2],s[3]);const h=Cn(n),l=Cn(r);for(let e=0;e+4<=h.length;e+=4){l[e+0]=h[e+0]^f,l[e+1]=h[e+1]^c,l[e+2]=h[e+2]^a,l[e+3]=h[e+3]^u;let n=1;for(let t=i.length-1;t>=0;t--)n=n+(255&i[t])|0,i[t]=255&n,n>>>=8;({s0:f,s1:c,s2:a,s3:u}=Br(t,s[0],s[1],s[2],s[3]))}const d=fr*Math.floor(h.length/4);if(d<o){const t=new Uint32Array([f,c,a,u]),e=qn(t);for(let t=d,i=0;t<o;t++,i++)r[t]=n[t]^e[i]}return r}(o,i,n,r);return o.fill(0),i.fill(0),s}return Kn(t),Kn(e,fr),{encrypt:(t,e)=>n(t,e),decrypt:(t,e)=>n(t,e)}})),Wn({blockSize:16},(function(t,e={}){Kn(t);const n=!e.disablePadding;return{encrypt:(e,r)=>{Kn(e);const{b:o,o:i,out:s}=kr(e,n,r),f=xr(t);let c=0;for(;c+4<=o.length;){const{s0:t,s1:e,s2:n,s3:r}=Br(f,o[c+0],o[c+1],o[c+2],o[c+3]);i[c++]=t,i[c++]=e,i[c++]=n,i[c++]=r}if(n){const t=$r(e.subarray(4*c)),{s0:n,s1:r,s2:o,s3:s}=Br(f,t[0],t[1],t[2],t[3]);i[c++]=n,i[c++]=r,i[c++]=o,i[c++]=s}return f.fill(0),s},decrypt:(e,r)=>{Sr(e);const o=Er(t),i=Ir(e.length,r),s=Cn(e),f=Cn(i);for(let t=0;t+4<=s.length;){const{s0:e,s1:n,s2:r,s3:i}=_r(o,s[t+0],s[t+1],s[t+2],s[t+3]);f[t++]=e,f[t++]=n,f[t++]=r,f[t++]=i}return o.fill(0),Lr(i,n)}}}));const Or=Wn({blockSize:16,nonceLength:16},(function(t,e,n={}){Kn(t),Kn(e,16);const r=!n.disablePadding;return{encrypt:(n,o)=>{const i=xr(t),{b:s,o:f,out:c}=kr(n,r,o),a=Cn(e);let u=a[0],h=a[1],l=a[2],d=a[3],g=0;for(;g+4<=s.length;)u^=s[g+0],h^=s[g+1],l^=s[g+2],d^=s[g+3],({s0:u,s1:h,s2:l,s3:d}=Br(i,u,h,l,d)),f[g++]=u,f[g++]=h,f[g++]=l,f[g++]=d;if(r){const t=$r(n.subarray(4*g));u^=t[0],h^=t[1],l^=t[2],d^=t[3],({s0:u,s1:h,s2:l,s3:d}=Br(i,u,h,l,d)),f[g++]=u,f[g++]=h,f[g++]=l,f[g++]=d}return i.fill(0),c},decrypt:(n,o)=>{Sr(n);const i=Er(t),s=Cn(e),f=Ir(n.length,o),c=Cn(n),a=Cn(f);let u=s[0],h=s[1],l=s[2],d=s[3];for(let t=0;t+4<=c.length;){const e=u,n=h,r=l,o=d;u=c[t+0],h=c[t+1],l=c[t+2],d=c[t+3];const{s0:s,s1:f,s2:g,s3:y}=_r(i,u,h,l,d);a[t++]=s^e,a[t++]=f^n,a[t++]=g^r,a[t++]=y^o}return i.fill(0),Lr(f,r)}}}));function Tr(t,e,n,r,o){const i=t.create(n,r.length+(o?.length||0));o&&i.update(o),i.update(r);const s=new Uint8Array(16),f=Dn(s);return o&&Zn(f,0,BigInt(8*o.length),e),Zn(f,8,BigInt(8*r.length),e),i.update(s),i.digest()}const Hr=Wn({blockSize:16,nonceLength:12,tagLength:16},(function(t,e,n){if(Kn(e),0===e.length)throw new Error("aes/gcm: empty nonce");const r=16;function o(t,e,r){const o=Tr(ir,!1,t,r,n);for(let t=0;t<e.length;t++)o[t]^=e[t];return o}function i(){const n=xr(t),r=cr.slice(),o=cr.slice();if(Ur(n,!1,o,o,r),12===e.length)o.set(e);else{const t=cr.slice();Zn(Dn(t),8,BigInt(8*e.length),!1),ir.create(r).update(e).update(t).digestInto(o)}return{xk:n,authKey:r,counter:o,tagMask:Ur(n,!1,o,cr)}}return{encrypt:t=>{Kn(t);const{xk:e,authKey:n,counter:s,tagMask:f}=i(),c=new Uint8Array(t.length+r);Ur(e,!1,s,t,c);const a=o(n,f,c.subarray(0,c.length-r));return c.set(a,t.length),e.fill(0),c},decrypt:t=>{if(Kn(t),t.length<r)throw new Error("aes/gcm: ciphertext less than tagLen (16)");const{xk:e,authKey:n,counter:s,tagMask:f}=i(),c=t.subarray(0,-16),a=t.subarray(-16);if(!Gn(o(n,f,c),a))throw new Error("aes/gcm: invalid ghash tag");const u=Ur(e,!1,s,c);return n.fill(0),f.fill(0),e.fill(0),u}}})),Rr=(t,e,n)=>r=>{if(!Number.isSafeInteger(r)||e>r||r>n)throw new Error(`${t}: invalid value=${r}, must be [${e}..${n}]`)};Wn({blockSize:16,nonceLength:12,tagLength:16},(function(t,e,n){const r=Rr("AAD",0,2**36),o=Rr("plaintext",0,2**36),i=Rr("nonce",12,12),s=Rr("ciphertext",16,2**36+16);function f(){const n=t.length;if(16!==n&&24!==n&&32!==n)throw new Error(`key length must be 16, 24 or 32 bytes, got: ${n} bytes`);const r=xr(t),o=new Uint8Array(n),i=new Uint8Array(16),s=Cn(e);let f=0,c=s[0],a=s[1],u=s[2],h=0;for(const t of[i,o].map(Cn)){const e=Cn(t);for(let t=0;t<e.length;t+=2){const{s0:n,s1:o}=Br(r,f,c,a,u);e[t+0]=n,e[t+1]=o,f=++h}}return r.fill(0),{authKey:i,encKey:xr(o)}}function c(t,r,o){const i=Tr(sr,!0,r,o,n);for(let t=0;t<12;t++)i[t]^=e[t];i[15]&=127;const s=Cn(i);let f=s[0],c=s[1],a=s[2],u=s[3];return({s0:f,s1:c,s2:a,s3:u}=Br(t,f,c,a,u)),s[0]=f,s[1]=c,s[2]=a,s[3]=u,i}function a(t,e,n){let r=e.slice();return r[15]|=128,Ur(t,!0,r,n)}return Kn(e),i(e.length),n&&(Kn(n),r(n.length)),{encrypt:t=>{Kn(t),o(t.length);const{encKey:e,authKey:n}=f(),r=c(e,n,t),i=new Uint8Array(t.length+16);return i.set(r,t.length),i.set(a(e,r,t)),e.fill(0),n.fill(0),i},decrypt:t=>{Kn(t),s(t.length);const e=t.subarray(-16),{encKey:n,authKey:r}=f(),o=a(n,e,t.subarray(0,-16)),i=c(n,r,o);if(n.fill(0),r.fill(0),!Gn(e,i))throw new Error("invalid polyval tag");return o}}}));var jr=Object.freeze({__proto__:null,decrypt_cbc:function(t,e,n){const r=De.bytes(t),o=De.bytes(e),i=De.bytes(n);Ln(i,16);const s=Or(o,i).decrypt(r);return De.raw(s)},decrypt_gcm:function(t,e,n){const r=De.bytes(t),o=De.bytes(e),i=De.bytes(n);Ln(i,12);const s=Hr(o,i).decrypt(r);return De.raw(s)},encrypt_cbc:function(t,e,n){const r=De.bytes(t),o=De.bytes(e),i=De.bytes(n);Ln(i,16);const s=Or(o,i).encrypt(r);return De.raw(s)},encrypt_gcm:function(t,e,n){const r=De.bytes(t),o=De.bytes(e),i=De.bytes(n);Ln(i,12);const s=Hr(o,i).encrypt(r);return De.raw(s)}});function Nr(t,n,o,i){r(t);const s=function(t,e){if(void 0!==e&&"[object Object]"!==h.call(e))throw new Error("Options should be object or undefined");return Object.assign(t,e)}({dkLen:32,asyncTick:10},i),{c:f,dkLen:c,asyncTick:u}=s;if(e(f),e(c),e(u),f<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const l=a(n),d=a(o),g=new Uint8Array(c),y=xt.create(t,l),w=y._cloneInto().update(d);return{c:f,dkLen:c,asyncTick:u,DK:g,PRF:y,PRFSalt:w}}function zr(t,e,n,r){const{c:o,dkLen:i,DK:s,PRF:c,PRFSalt:a}=Nr(t,e,n,r);let u;const h=new Uint8Array(4),l=f(h),d=new Uint8Array(c.outputLen);for(let t=1,e=0;e<i;t++,e+=c.outputLen){const n=s.subarray(e,e+c.outputLen);l.setInt32(0,t,!1),(u=a._cloneInto(u)).update(h).digestInto(d),n.set(d.subarray(0,n.length));for(let t=1;t<o;t++){c._cloneInto(u).update(d).digestInto(d);for(let t=0;t<n.length;t++)n[t]^=d[t]}}return function(t,e,n,r,o){return t.destroy(),e.destroy(),r&&r.destroy(),o.fill(0),n}(c,a,s,u,d)}const Pr=BigInt(2**32-1),qr=BigInt(32);function Cr(t,e=!1){return e?{h:Number(t&Pr),l:Number(t>>qr&Pr)}:{h:0|Number(t>>qr&Pr),l:0|Number(t&Pr)}}const Fr={fromBig:Cr,split:function(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:s}=Cr(t[o],e);[n[o],r[o]]=[i,s]}return[n,r]},toBig:(t,e)=>BigInt(t>>>0)<<qr|BigInt(e>>>0),shrSH:(t,e,n)=>t>>>n,shrSL:(t,e,n)=>t<<32-n|e>>>n,rotrSH:(t,e,n)=>t>>>n|e<<32-n,rotrSL:(t,e,n)=>t<<32-n|e>>>n,rotrBH:(t,e,n)=>t<<64-n|e>>>n-32,rotrBL:(t,e,n)=>t>>>n-32|e<<64-n,rotr32H:(t,e)=>e,rotr32L:(t,e)=>t,rotlSH:(t,e,n)=>t<<n|e>>>32-n,rotlSL:(t,e,n)=>e<<n|t>>>32-n,rotlBH:(t,e,n)=>e<<n-32|t>>>64-n,rotlBL:(t,e,n)=>t<<n-32|e>>>64-n,add:function(t,e,n,r){const o=(e>>>0)+(r>>>0);return{h:t+n+(o/2**32|0)|0,l:0|o}},add3L:(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),add3H:(t,e,n,r)=>e+n+r+(t/2**32|0)|0,add4L:(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),add4H:(t,e,n,r,o)=>e+n+r+o+(t/2**32|0)|0,add5H:(t,e,n,r,o,i)=>e+n+r+o+i+(t/2**32|0)|0,add5L:(t,e,n,r,o)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(o>>>0)},[Dr,Vr]=(()=>Fr.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((t=>BigInt(t)))))(),Kr=new Uint32Array(80),Gr=new Uint32Array(80);class Wr extends g{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:n,Bl:r,Ch:o,Cl:i,Dh:s,Dl:f,Eh:c,El:a,Fh:u,Fl:h,Gh:l,Gl:d,Hh:g,Hl:y}=this;return[t,e,n,r,o,i,s,f,c,a,u,h,l,d,g,y]}set(t,e,n,r,o,i,s,f,c,a,u,h,l,d,g,y){this.Ah=0|t,this.Al=0|e,this.Bh=0|n,this.Bl=0|r,this.Ch=0|o,this.Cl=0|i,this.Dh=0|s,this.Dl=0|f,this.Eh=0|c,this.El=0|a,this.Fh=0|u,this.Fl=0|h,this.Gh=0|l,this.Gl=0|d,this.Hh=0|g,this.Hl=0|y}process(t,e){for(let n=0;n<16;n++,e+=4)Kr[n]=t.getUint32(e),Gr[n]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|Kr[t-15],n=0|Gr[t-15],r=Fr.rotrSH(e,n,1)^Fr.rotrSH(e,n,8)^Fr.shrSH(e,n,7),o=Fr.rotrSL(e,n,1)^Fr.rotrSL(e,n,8)^Fr.shrSL(e,n,7),i=0|Kr[t-2],s=0|Gr[t-2],f=Fr.rotrSH(i,s,19)^Fr.rotrBH(i,s,61)^Fr.shrSH(i,s,6),c=Fr.rotrSL(i,s,19)^Fr.rotrBL(i,s,61)^Fr.shrSL(i,s,6),a=Fr.add4L(o,c,Gr[t-7],Gr[t-16]),u=Fr.add4H(a,r,f,Kr[t-7],Kr[t-16]);Kr[t]=0|u,Gr[t]=0|a}let{Ah:n,Al:r,Bh:o,Bl:i,Ch:s,Cl:f,Dh:c,Dl:a,Eh:u,El:h,Fh:l,Fl:d,Gh:g,Gl:y,Hh:w,Hl:p}=this;for(let t=0;t<80;t++){const e=Fr.rotrSH(u,h,14)^Fr.rotrSH(u,h,18)^Fr.rotrBH(u,h,41),b=Fr.rotrSL(u,h,14)^Fr.rotrSL(u,h,18)^Fr.rotrBL(u,h,41),m=u&l^~u&g,x=h&d^~h&y,E=Fr.add5L(p,b,x,Vr[t],Gr[t]),v=Fr.add5H(E,w,e,m,Dr[t],Kr[t]),A=0|E,B=Fr.rotrSH(n,r,28)^Fr.rotrBH(n,r,34)^Fr.rotrBH(n,r,39),_=Fr.rotrSL(n,r,28)^Fr.rotrBL(n,r,34)^Fr.rotrBL(n,r,39),I=n&o^n&s^o&s,U=r&i^r&f^i&f;w=0|g,p=0|y,g=0|l,y=0|d,l=0|u,d=0|h,({h:u,l:h}=Fr.add(0|c,0|a,0|v,0|A)),c=0|s,a=0|f,s=0|o,f=0|i,o=0|n,i=0|r;const S=Fr.add3L(A,_,U);n=Fr.add3H(S,v,B,I),r=0|S}({h:n,l:r}=Fr.add(0|this.Ah,0|this.Al,0|n,0|r)),({h:o,l:i}=Fr.add(0|this.Bh,0|this.Bl,0|o,0|i)),({h:s,l:f}=Fr.add(0|this.Ch,0|this.Cl,0|s,0|f)),({h:c,l:a}=Fr.add(0|this.Dh,0|this.Dl,0|c,0|a)),({h:u,l:h}=Fr.add(0|this.Eh,0|this.El,0|u,0|h)),({h:l,l:d}=Fr.add(0|this.Fh,0|this.Fl,0|l,0|d)),({h:g,l:y}=Fr.add(0|this.Gh,0|this.Gl,0|g,0|y)),({h:w,l:p}=Fr.add(0|this.Hh,0|this.Hl,0|w,0|p)),this.set(n,r,o,i,s,f,c,a,u,h,l,d,g,y,w,p)}roundClean(){Kr.fill(0),Gr.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Zr=l((()=>new Wr)),Yr=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Mr=Uint8Array.from({length:16},((t,e)=>e));let Jr=[Mr],Xr=[Mr.map((t=>(9*t+5)%16))];for(let t=0;t<4;t++)for(let e of[Jr,Xr])e.push(e[t].map((t=>Yr[t])));const Qr=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((t=>new Uint8Array(t))),to=Jr.map(((t,e)=>t.map((t=>Qr[e][t])))),eo=Xr.map(((t,e)=>t.map((t=>Qr[e][t])))),no=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),ro=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),oo=(t,e)=>t<<e|t>>>32-e;function io(t,e,n,r){return 0===t?e^n^r:1===t?e&n|~e&r:2===t?(e|~n)^r:3===t?e&r|n&~r:e^(n|~r)}const so=new Uint32Array(16);class fo extends g{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:n,h3:r,h4:o}=this;return[t,e,n,r,o]}set(t,e,n,r,o){this.h0=0|t,this.h1=0|e,this.h2=0|n,this.h3=0|r,this.h4=0|o}process(t,e){for(let n=0;n<16;n++,e+=4)so[n]=t.getUint32(e,!0);let n=0|this.h0,r=n,o=0|this.h1,i=o,s=0|this.h2,f=s,c=0|this.h3,a=c,u=0|this.h4,h=u;for(let t=0;t<5;t++){const e=4-t,l=no[t],d=ro[t],g=Jr[t],y=Xr[t],w=to[t],p=eo[t];for(let e=0;e<16;e++){const r=oo(n+io(t,o,s,c)+so[g[e]]+l,w[e])+u|0;n=u,u=c,c=0|oo(s,10),s=o,o=r}for(let t=0;t<16;t++){const n=oo(r+io(e,i,f,a)+so[y[t]]+d,p[t])+h|0;r=h,h=a,a=0|oo(f,10),f=i,i=n}}this.set(this.h1+s+a|0,this.h2+c+h|0,this.h3+u+r|0,this.h4+n+i|0,this.h0+o+f|0)}roundClean(){so.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const co=l((()=>new fo));function ao(...t){const e=De.join(t);return De.raw(x(e))}function uo(...t){const e=De.join(t);return De.raw(co(x(e)))}function ho(t,...e){const n=De.bytes(t),r=De.join(e);return De.raw(xt(Zr,n,r))}function lo(t){const e=De.str(t).digest;return De.join([e,e])}function go(t,...e){const n=lo(t);return De.join([n,...e]).digest}var yo=Object.freeze({__proto__:null,hash160:uo,hash256:function(...t){const e=De.join(t);return De.raw(x(x(e)))},hash340:go,hmac256:function(t,...e){const n=De.bytes(t),r=De.join(e);return De.raw(xt(x,n,r))},hmac512:ho,pkdf256:function(t,e,n=2048){const r=De.bytes(t),o=De.bytes(e),i=zr(x,r,o,{c:n,dkLen:32});return De.raw(i)},pkdf512:function(t,e,n=2048){const r=De.bytes(t),o=De.bytes(e),i=zr(Zr,r,o,{c:n,dkLen:64});return De.raw(i)},ripe160:function(...t){const e=De.join(t);return De.raw(co(e))},sha256:ao,sha512:function(...t){const e=De.join(t);return De.raw(Zr(e))},taghash:lo});function wo(t){return De.random(t)}var po=Object.freeze({__proto__:null,increment_buffer:function(t){let e=t.length-1;for(;e>=0;e--)if(t[e]<255)return t.set([t[e]+1],e),t;throw TypeError("Unable to increment buffer: "+t.toString())},random:wo,stringify:function(t){switch(typeof t){case"object":return JSON.stringify(t);case"string":return t;case"bigint":case"number":return t.toString();case"boolean":return String(t);default:throw new TypeError("Content type not supported: "+typeof t)}}});function bo(t,e=!1){const n=zn.mod(t);return e?n.negated.buff:n.buff}function mo(t,e=!1){const n=zn.mod(t).point;return e?n.x:n.buff}function xo(t,e,n){const r=bo(t,n);return[r,mo(r,e)]}function Eo(t){const e=De.bytes(t);if(32===e.length)return e;if(33===e.length)return e.slice(1,33);throw new TypeError(`Invalid key length: ${e.length}`)}function vo(t,e=!1){const n=De.bytes(t);if(32===n.length)return n.prepend(2);if(33===n.length)return e&&(n[0]=2),n;throw new TypeError(`Invalid key size: ${n.length}`)}var Ao=Object.freeze({__proto__:null,convert_32b:Eo,convert_33b:vo,gen_keypair:function(t,e){return xo(wo(32),t,e)},gen_seckey:function(t){return bo(wo(32),t)},get_keypair:xo,get_pubkey:mo,get_seckey:bo,has_key:function(t,e){return e.map((t=>De.bytes(t).hex)).includes(De.bytes(t).hex)},is_even_pub:function(t){const e=De.bytes(t);switch(!0){case 32===e.length:case 33===e.length&&2===e[0]:return!0;case 33===e.length&&3===e[0]:return!1;default:throw new TypeError(`Invalid public key: ${e.hex}`)}},parse_pubkey:function(t,e){return e?Eo(t):vo(t)},sort_keys:function(t){return t.map((t=>De.bytes(t).hex)).sort().map((t=>De.hex(t)))},tweak_pubkey:function(t,e=[],n=!1){let r=Pn.from_x(t,n);for(const t of e)r=r.add(t),n&&(r=r.negated);return n?r.x:r.buff},tweak_seckey:function(t,e=[],n=!1){let r=zn.mod(t);for(const t of e)r=r.add(t),n&&(r=r.negated);return r.buff}});const Bo=/^[0-9]{0,10}$/,_o=/^[0-9a-zA-Z_&?=]{64}$/;function Io(t,e,n,r=!1){Tn(t,n);const o=De.bytes(e);let i,s=void 0!==n?De.bytes(n):De.str("Bitcoin seed"),f=null,c=null;if(t.startsWith("m")){const t=So(s,o);s=t[1],c=t[0],i=mo(c,!1)}else r?(Ln(e,32),c=o,i=mo(c,!1)):(Ln(o,33),i=o);const a=Uo(t);for(const[t,e]of a){const n=e&&null!==c?De.join([0,c,t]):De.join([i,t]),[r,o]=So(s,n);s=De.raw(o),f=i,null!==c?(c=zn.mod(c).add(r).buff,i=mo(c,!1),On(c.big,!0)):(i=Pn.from_x(i).add(r).buff,$n(i.slice(1).big,!0))}return{seckey:c,pubkey:i,code:s,path:t,prev:f}}function Uo(t){Hn(t);const e=[];let n=t.split("/");"m"!==n[0]&&""!==n[0]||(n=n.slice(1));for(let t of n){let n=!1;if("'"===t.slice(-1)&&(n=!0,t=t.slice(0,-1)),null!==t.match(Bo)){let r=parseInt(t,10);Rn(r),n&&(r+=2147483648),e.push([De.num(r,4),n])}else{if(null===t.match(_o))throw new Error("Invalid path segment:"+t);{let r=De.str(t);n&&(r=r.prepend(128)),e.push([r.digest,n])}}}return e}function So(t,e){const n=ho(t,e);return[n.slice(0,32),n.slice(32)]}function ko(t){const e=De.b58chk(t).stream,n=e.read(4).num,r=e.read(1).num,o=e.read(4).num,i=e.read(4).num,s=e.read(32).hex,f=e.read(1).num,c=e.read(32).hex,a=0===f?c:void 0,u=0===f?mo(c).hex:De.join([f,c]).hex;if(e.size>0)throw new TypeError("Unparsed data remaining in buffer!");return{prefix:n,depth:r,fprint:o,index:i,code:s,type:f,key:c,seckey:a,pubkey:u}}var Lo=Object.freeze({__proto__:null,derive_extkey:function(t,e=""){const{code:n,type:r,key:o}=ko(t),i=0===r;return Io(e,i?o:De.join([r,o]),n,i)},derive_key:Io,derive_pubkey:function(t,e,n){return Io(t,e,n,!1)},derive_seckey:function(t,e,n){return Io(t,e,n,!0)},derive_seed:function(t,e){return Io(t,e,void 0,!0)},encode_extkey:function(t,e){const{seckey:n,pubkey:r,code:o,prev:i,path:s}=t,f="number"==typeof e?De.num(e,4):null!==n?76066276:76067358,c=Uo(s),a=c.at(-1),u=De.num(c.length,1),h=null!==i?uo(i).slice(0,4):De.num(0,4),l=void 0!==a?a[0].slice(-4,4):De.num(0,4),d=null!==n?n.prepend(0):r;return De.join([f,u,h,l,o,d]).to_b58chk()},generate_code:So,parse_extkey:ko,parse_tweaks:Uo});function $o(t,e=null,n=[],r=Oo){const o=[],i=[];if(t.length<1)throw new Error("Tree is empty!");for(let r=0;r<t.length;r++){const i=t[r];if(Array.isArray(i)){const[t,r,s]=$o(i,e);e=r,o.push(t);for(const t of s)n.push(t)}else o.push(i)}if(1===o.length)return[o[0],e,n];o.sort(),o.length%2!=0&&o.push(o[o.length-1]);for(let t=0;t<o.length-1;t+=2){const s=r(o[t],o[t+1]);i.push(s),"string"==typeof e&&(e===o[t]?(n.push(o[t+1]),e=s):e===o[t+1]&&(n.push(o[t]),e=s))}return $o(i,e,n)}function Oo(t,e){return e<t&&([t,e]=[e,t]),ao(t,e).hex}var To=Object.freeze({__proto__:null,create_merkle_proof:function(t,e,n=Oo){const r=t.map((t=>De.bytes(t).hex)),o=De.bytes(e).hex,[i,s,f]=$o(r,o,[],n);return{root:De.hex(i),path:f.map((t=>De.hex(t)))}},encode_branch:Oo,merkleize_tree:$o,verify_merkle_proof:function(t,e,n,r=Oo){const o=t.map((t=>De.bytes(t).hex));let i=De.bytes(e).hex;for(const t of o)i=r(i,t);return De.is_equal(n,i)}});function Ho(t,e,n={}){const{aux:r,nonce_seed:o,nonce_tweak:i,sec_nonce:s}=n;let f;if(void 0!==o)f=De.bytes(o);else{const t=go("BIP0340/aux",(null===r?De.num(0,32):r)??De.random(32)),n=De.bytes(e).big^t.big;f=De.join([n,mo(e,!0)])}let c=void 0!==s?zn.mod(s):zn.mod(go("BIP0340/nonce",f,t));return void 0!==i&&(c=c.negated.add(i)),c.buff}var Ro=Object.freeze({__proto__:null,gen_nonce:Ho,recover_key:function(t,e,n,r){const o=De.bytes(e),i=De.bytes(r),s=zn.mod(i.slice(32,64)),f=go("BIP0340/nonce",n,t),c=go("BIP0340/challenge",i.slice(0,32),o,t),a=bo(f,!0);return s.sub(a).div(c).buff},sign_msg:function(t,e,n={}){const{adaptor:r,key_tweak:o}=n,i=De.bytes(t);let s=zn.mod(e);void 0!==o&&(s=s.negated.add(o));const f=s.point,c=s.negated,a=Ho(i,c,n);let u=zn.mod(a);void 0!==r&&(u=u.negated.add(r));const h=u.point,l=u.negated.big,d=go("BIP0340/challenge",h.x,f.x,i),g=zn.mod(d),y=zn.mod(l+g.big*c.big);return De.join([h.x,y.raw])},verify_sig:function(t,e,n,r={}){const{throws:o=!1}=r,i=De.bytes(e),s=De.bytes(t);if(s.length<64)return kn("Signature length is too small: "+String(s.length),o);Ln(n,32);const f=Pn.from_x(n),c=s.subarray(0,32),a=Pn.from_x(c),u=s.subarray(32,64),h=zn.mod(u).point,l=go("BIP0340/challenge",a.x,f.x,i),d=zn.mod(l),g=f.mul(d.big),y=h.sub(g);return a.hasOddY?kn("Signature R value has odd Y coordinate!",o):a.x.big===hn?kn("Signature R value is infinite!",o):a.x.big!==y.x.big?kn(`Signature is invalid! R: ${a.x.hex} r:${y.x.hex}`,o):a.x.big===y.x.big}});var jo=Object.freeze({__proto__:null,combine_shares:function(t){const e=t.map((t=>{const e=De.bytes(t);return[e.subarray(0,4).big,e.subarray(4).big]}));let n=hn;for(let t=0;t<e.length;t++){let r=ln,o=ln;for(let n=0;n<e.length;n++)t!==n&&(r=r*-e[n][0]%cn,o=o*(e[t][0]-e[n][0])%cn);r<hn&&(r+=cn),o<hn&&(o+=cn);n=(n+e[t][1]*r*et(o,cn)%cn)%cn}return De.big(n,32)},create_shares:function(t,e,n){const r=[zn.mod(t).big];for(let t=1;t<e;t++){const t=De.random(32).big;r.push(_n(t))}const o=[];for(let t=1;t<=n;t++){let e=hn;r.forEach(((n,r)=>{const o=BigInt(t)**BigInt(r);e+=An.mul(n,o)}));const n=De.num(t,4),i=De.big(e,33),s=De.join([n,i]);o.push(s)}return o}});const No={secp:kt,schnorr:Wt};return t.CONST=wn,t.Field=zn,t.Point=Pn,t.assert=jn,t.cipher=jr,t.hash=yo,t.hd=Lo,t.keys=Ao,t.math=Sn,t.merkle=To,t.noble=No,t.shamir=jo,t.signer=Ro,t.util=po,t}({});
//# sourceMappingURL=script.js.map
