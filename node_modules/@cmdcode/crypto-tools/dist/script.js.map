{"version":3,"file":"script.js","sources":["../node_modules/@noble/hashes/esm/_assert.js","../node_modules/@noble/hashes/esm/crypto.js","../node_modules/@noble/hashes/esm/utils.js","../node_modules/@noble/hashes/esm/_sha2.js","../node_modules/@noble/hashes/esm/sha256.js","../node_modules/@noble/curves/esm/abstract/utils.js","../node_modules/@noble/curves/esm/abstract/modular.js","../node_modules/@noble/curves/esm/abstract/curve.js","../node_modules/@noble/curves/esm/abstract/weierstrass.js","../node_modules/@noble/hashes/esm/hmac.js","../node_modules/@noble/curves/esm/_shortw_utils.js","../node_modules/@noble/curves/esm/secp256k1.js","../node_modules/@cmdcode/buff/dist/assert.js","../node_modules/@cmdcode/buff/dist/format/str.js","../node_modules/@scure/base/lib/esm/index.js","../node_modules/@cmdcode/buff/dist/encode.js","../node_modules/@cmdcode/buff/dist/format/big.js","../node_modules/@cmdcode/buff/dist/format/num.js","../node_modules/@cmdcode/buff/dist/utils.js","../node_modules/@cmdcode/buff/dist/format/buffer.js","../node_modules/@cmdcode/buff/dist/buff.js","../node_modules/@cmdcode/buff/dist/format/bin.js","../src/const.ts","../src/lib/point.ts","../src/lib/math.ts","../src/assert.ts","../src/lib/ecc.ts","../node_modules/@noble/ciphers/esm/utils.js","../node_modules/@noble/ciphers/esm/_assert.js","../node_modules/@noble/ciphers/esm/_polyval.js","../node_modules/@noble/ciphers/esm/aes.js","../src/lib/cipher.ts","../node_modules/@noble/hashes/esm/pbkdf2.js","../node_modules/@noble/hashes/esm/_u64.js","../node_modules/@noble/hashes/esm/sha512.js","../node_modules/@noble/hashes/esm/ripemd160.js","../src/lib/hash.ts","../src/util.ts","../src/lib/keys.ts","../src/lib/hd.ts","../src/lib/merkle.ts","../src/lib/sig.ts","../src/lib/shamir.ts","../src/index.ts"],"sourcesContent":["function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    let res = new Uint8Array(sum);\n    let pad = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport { bitMask, numberToBytesBE, numberToBytesLE, bytesToNumberBE, bytesToNumberLE, ensureBytes, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nexport function invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexport function FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!ut.isBytes(data))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || ut.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assertExists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assertExists(this);\n        assertBytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from './abstract/weierstrass.js';\n// connects noble-curves to noble-hashes\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexport const secp256k1 = createCurve({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","export function within_size(data, size) {\n    if (data.length > size) {\n        throw new TypeError(`Data is larger than array size: ${data.length} > ${size}`);\n    }\n}\nexport function is_hex(hex) {\n    if (hex.match(/[^a-fA-f0-9]/) !== null) {\n        throw new TypeError('Invalid characters in hex string: ' + hex);\n    }\n    if (hex.length % 2 !== 0) {\n        throw new Error(`Length of hex string is invalid: ${hex.length}`);\n    }\n}\nexport function is_json(str) {\n    try {\n        JSON.parse(str);\n    }\n    catch {\n        throw new TypeError('JSON string is invalid!');\n    }\n}\nexport function is_safe_num(num) {\n    if (num > Number.MAX_SAFE_INTEGER) {\n        throw new TypeError('Number exceeds safe bounds!');\n    }\n}\nexport function is_prefix(actual, target) {\n    if (actual !== target) {\n        throw new TypeError(`Bech32 prefix does not match: ${actual} !== ${target}`);\n    }\n}\n//# sourceMappingURL=assert.js.map","import { is_hex } from '../assert.js';\nconst ec = new TextEncoder();\nconst dc = new TextDecoder();\nexport function strToBytes(str) {\n    return ec.encode(str);\n}\nexport function bytesToStr(bytes) {\n    return dc.decode(bytes);\n}\nfunction hex_size(hexstr, size) {\n    is_hex(hexstr);\n    const len = hexstr.length / 2;\n    if (size === undefined)\n        size = len;\n    if (len > size) {\n        throw new TypeError(`Hex string is larger than array size: ${len} > ${size}`);\n    }\n    return size;\n}\nexport function hexToBytes(hexstr, size, endian = 'le') {\n    size = hex_size(hexstr, size);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    for (let i = 0; i < hexstr.length; i += 2) {\n        const char = hexstr.substring(i, i + 2);\n        const num = parseInt(char, 16);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n    }\n    return new Uint8Array(buffer);\n}\nexport function bytesToHex(bytes) {\n    let chars = '';\n    for (let i = 0; i < bytes.length; i++) {\n        chars += bytes[i].toString(16).padStart(2, '0');\n    }\n    return chars;\n}\n//# sourceMappingURL=str.js.map","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const createBase58check = /* @__PURE__ */ (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexport const bech32 = /* @__PURE__ */ genBech32('bech32');\nexport const bech32m = /* @__PURE__ */ genBech32('bech32m');\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexport const hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n","import { sha256 } from '@noble/hashes/sha256';\nimport { bytesToStr, bytesToHex, hexToBytes, strToBytes } from './format/str.js';\nimport { base58check, base64, base64urlnopad, bech32, bech32m } from '@scure/base';\nexport const Hex = {\n    encode: bytesToHex,\n    decode: hexToBytes\n};\nexport const Txt = {\n    encode: strToBytes,\n    decode: bytesToStr\n};\nexport const B58chk = {\n    encode: (data) => base58check(sha256).encode(data),\n    decode: (data) => base58check(sha256).decode(data)\n};\nexport const Base64 = {\n    encode: (data) => base64.encode(data),\n    decode: (data) => base64.decode(data)\n};\nexport const B64url = {\n    encode: (data) => base64urlnopad.encode(data),\n    decode: (data) => base64urlnopad.decode(data)\n};\nexport const Bech32 = {\n    to_words: bech32.toWords,\n    to_bytes: bech32.fromWords,\n    encode: (prefix, words, limit = false) => {\n        return bech32.encode(prefix, words, limit);\n    },\n    decode: (data, limit = false) => {\n        const { prefix, words } = bech32.decode(data, limit);\n        return { prefix, words };\n    }\n};\nexport const Bech32m = {\n    to_words: bech32m.toWords,\n    to_bytes: bech32m.fromWords,\n    encode: (prefix, words, limit = false) => {\n        return bech32m.encode(prefix, words, limit);\n    },\n    decode: (data, limit = false) => {\n        const { prefix, words } = bech32m.decode(data, limit);\n        return { prefix, words };\n    }\n};\n//# sourceMappingURL=encode.js.map","const _0n = BigInt(0);\nconst _255n = BigInt(255);\nconst _256n = BigInt(256);\nfunction big_size(big) {\n    if (big <= 0xffn)\n        return 1;\n    if (big <= 0xffffn)\n        return 2;\n    if (big <= 0xffffffffn)\n        return 4;\n    if (big <= 0xffffffffffffffffn)\n        return 8;\n    if (big <= 0xffffffffffffffffffffffffffffffffn)\n        return 16;\n    if (big <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn) {\n        return 32;\n    }\n    throw new TypeError('Must specify a fixed buffer size for bigints greater than 32 bytes.');\n}\nexport function bigToBytes(big, size, endian = 'be') {\n    if (size === undefined)\n        size = big_size(big);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (big > _0n) {\n        const byte = big & _255n;\n        const num = Number(byte);\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        big = (big - byte) / _256n;\n    }\n    return new Uint8Array(buffer);\n}\nexport function bytesToBig(bytes) {\n    let num = BigInt(0);\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * _256n) + BigInt(bytes[i]);\n    }\n    return BigInt(num);\n}\n//# sourceMappingURL=big.js.map","import { is_safe_num } from '../assert.js';\nfunction num_size(num) {\n    if (num <= 0xFF)\n        return 1;\n    if (num <= 0xFFFF)\n        return 2;\n    if (num <= 0xFFFFFFFF)\n        return 4;\n    throw new TypeError('Numbers larger than 4 bytes must specify a fixed size!');\n}\nexport function numToBytes(num, size, endian = 'be') {\n    if (size === undefined)\n        size = num_size(num);\n    const use_le = (endian === 'le');\n    const buffer = new ArrayBuffer(size);\n    const dataView = new DataView(buffer);\n    let offset = (use_le) ? 0 : size - 1;\n    while (num > 0) {\n        const byte = num & 255;\n        if (use_le) {\n            dataView.setUint8(offset++, num);\n        }\n        else {\n            dataView.setUint8(offset--, num);\n        }\n        num = (num - byte) / 256;\n    }\n    return new Uint8Array(buffer);\n}\nexport function bytesToNum(bytes) {\n    let num = 0;\n    for (let i = bytes.length - 1; i >= 0; i--) {\n        num = (num * 256) + bytes[i];\n        is_safe_num(num);\n    }\n    return num;\n}\n//# sourceMappingURL=num.js.map","import { within_size } from './assert.js';\nexport function is_hex(input) {\n    if (input.match(/[^a-fA-F0-9]/) === null &&\n        input.length % 2 === 0) {\n        return true;\n    }\n    return false;\n}\nexport function is_bytes(input) {\n    if (typeof input === 'string' && is_hex(input)) {\n        return true;\n    }\n    else if (typeof input === 'number' ||\n        typeof input === 'bigint' ||\n        input instanceof Uint8Array) {\n        return true;\n    }\n    else if (Array.isArray(input) &&\n        input.every(e => typeof e === 'number')) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function set_buffer(data, size, endian = 'be') {\n    if (size === undefined)\n        size = data.length;\n    within_size(data, size);\n    const buffer = new Uint8Array(size).fill(0);\n    const offset = (endian === 'be') ? 0 : size - data.length;\n    buffer.set(data, offset);\n    return buffer;\n}\nexport function join_array(arr) {\n    let i, offset = 0;\n    const size = arr.reduce((len, arr) => len + arr.length, 0);\n    const buff = new Uint8Array(size);\n    for (i = 0; i < arr.length; i++) {\n        const a = arr[i];\n        buff.set(a, offset);\n        offset += a.length;\n    }\n    return buff;\n}\nexport function bigint_replacer(_, v) {\n    return typeof v === 'bigint'\n        ? `${v}n`\n        : v;\n}\nexport function bigint_reviver(_, v) {\n    return typeof v === 'string' && /^[0-9]+n$/.test(v)\n        ? BigInt(v.slice(0, -1))\n        : v;\n}\nexport function parse_data(data_blob, chunk_size, total_size) {\n    const len = data_blob.length, count = total_size / chunk_size;\n    if (total_size % chunk_size !== 0) {\n        throw new TypeError(`Invalid parameters: ${total_size} % ${chunk_size} !== 0`);\n    }\n    if (len !== total_size) {\n        throw new TypeError(`Invalid data stream: ${len} !== ${total_size}`);\n    }\n    if (len % chunk_size !== 0) {\n        throw new TypeError(`Invalid data stream: ${len} % ${chunk_size} !== 0`);\n    }\n    const chunks = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const idx = i * chunk_size;\n        chunks[i] = data_blob.subarray(idx, idx + chunk_size);\n    }\n    return chunks;\n}\n//# sourceMappingURL=utils.js.map","import { bigToBytes } from './big.js';\nimport { numToBytes } from './num.js';\nimport { hexToBytes } from './str.js';\nimport * as util from '../utils.js';\nexport function buffer_data(data, size, endian) {\n    if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    else if (data instanceof Uint8Array) {\n        return util.set_buffer(data, size, endian);\n    }\n    else if (Array.isArray(data)) {\n        const bytes = data.map(e => buffer_data(e, size, endian));\n        return util.join_array(bytes);\n    }\n    else if (typeof data === 'string') {\n        return hexToBytes(data, size, endian);\n    }\n    else if (typeof data === 'bigint') {\n        return bigToBytes(data, size, endian);\n    }\n    else if (typeof data === 'number') {\n        return numToBytes(data, size, endian);\n    }\n    else if (typeof data === 'boolean') {\n        return Uint8Array.of(data ? 1 : 0);\n    }\n    throw new TypeError('Unsupported format:' + String(typeof data));\n}\n//# sourceMappingURL=buffer.js.map","import { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport * as assert from './assert.js';\nimport * as encoder from './encode.js';\nimport * as fmt from './format/index.js';\nimport * as util from './utils.js';\nexport class Buff extends Uint8Array {\n    static { this.num = numToBuff; }\n    static { this.big = bigToBuff; }\n    static { this.bin = binToBuff; }\n    static { this.raw = rawToBuff; }\n    static { this.str = strToBuff; }\n    static { this.hex = hexToBuff; }\n    static { this.bytes = buffer; }\n    static { this.json = jsonToBuff; }\n    static { this.base64 = base64ToBuff; }\n    static { this.b64url = b64urlToBuff; }\n    static { this.bech32 = bech32ToBuff; }\n    static { this.bech32m = bech32mToBuff; }\n    static { this.b58chk = b58chkToBuff; }\n    static { this.encode = fmt.strToBytes; }\n    static { this.decode = fmt.bytesToStr; }\n    static { this.parse = parse_data; }\n    static { this.is_bytes = util.is_bytes; }\n    static { this.is_hex = util.is_hex; }\n    static { this.is_equal = is_equal; }\n    static random(size = 32) {\n        const rand = randomBytes(size);\n        return new Buff(rand, size);\n    }\n    static now(size = 4) {\n        const stamp = Math.floor(Date.now() / 1000);\n        return new Buff(stamp, size);\n    }\n    constructor(data, size, endian) {\n        if (data instanceof Buff &&\n            size === undefined) {\n            return data;\n        }\n        const buffer = fmt.buffer_data(data, size, endian);\n        super(buffer);\n    }\n    get arr() {\n        return [...this];\n    }\n    get num() {\n        return this.to_num();\n    }\n    get big() {\n        return this.to_big();\n    }\n    get str() {\n        return this.to_str();\n    }\n    get hex() {\n        return this.to_hex();\n    }\n    get raw() {\n        return new Uint8Array(this);\n    }\n    get bin() {\n        return this.to_bin();\n    }\n    get b58chk() {\n        return this.to_b58chk();\n    }\n    get base64() {\n        return this.to_base64();\n    }\n    get b64url() {\n        return this.to_b64url();\n    }\n    get digest() {\n        return this.to_hash();\n    }\n    get id() {\n        return this.to_hash().hex;\n    }\n    get stream() {\n        return new Stream(this);\n    }\n    to_num(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return fmt.bytesToNum(bytes);\n    }\n    to_big(endian = 'be') {\n        const bytes = (endian === 'be')\n            ? this.reverse()\n            : this;\n        return fmt.bytesToBig(bytes);\n    }\n    to_bin() {\n        return fmt.bytesToBin(this);\n    }\n    to_hash() {\n        const digest = sha256(this);\n        return new Buff(digest);\n    }\n    to_json(reviver) {\n        if (reviver === undefined) {\n            reviver = util.bigint_reviver;\n        }\n        const str = fmt.bytesToStr(this);\n        return JSON.parse(str, reviver);\n    }\n    to_bech32(prefix, limit) {\n        const { encode, to_words } = encoder.Bech32;\n        const words = to_words(this);\n        return encode(prefix, words, limit);\n    }\n    to_bech32m(prefix, limit) {\n        const { encode, to_words } = encoder.Bech32m;\n        const words = to_words(this);\n        return encode(prefix, words, limit);\n    }\n    to_str() { return fmt.bytesToStr(this); }\n    to_hex() { return fmt.bytesToHex(this); }\n    to_bytes() { return new Uint8Array(this); }\n    to_b58chk() { return encoder.B58chk.encode(this); }\n    to_base64() { return encoder.Base64.encode(this); }\n    to_b64url() { return encoder.B64url.encode(this); }\n    append(data) {\n        return Buff.join([this, Buff.bytes(data)]);\n    }\n    equals(data) {\n        return buffer(data).hex === this.hex;\n    }\n    prepend(data) {\n        return Buff.join([Buff.bytes(data), this]);\n    }\n    reverse() {\n        const arr = new Uint8Array(this).reverse();\n        return new Buff(arr);\n    }\n    slice(start, end) {\n        const arr = new Uint8Array(this).slice(start, end);\n        return new Buff(arr);\n    }\n    set(array, offset) {\n        this.set(array, offset);\n    }\n    subarray(begin, end) {\n        const arr = new Uint8Array(this).subarray(begin, end);\n        return new Buff(arr);\n    }\n    write(bytes, offset) {\n        const b = Buff.bytes(bytes);\n        this.set(b, offset);\n    }\n    add_varint(endian) {\n        const size = Buff.calc_varint(this.length, endian);\n        return Buff.join([size, this]);\n    }\n    toJSON() {\n        return this.hex;\n    }\n    toString() {\n        return this.hex;\n    }\n    static from(data) {\n        return new Buff(Uint8Array.from(data));\n    }\n    static of(...args) {\n        return new Buff(Uint8Array.of(...args));\n    }\n    static join(arr) {\n        const bytes = arr.map(e => Buff.bytes(e));\n        const joined = util.join_array(bytes);\n        return new Buff(joined);\n    }\n    static sort(arr, size) {\n        const hex = arr.map(e => buffer(e, size).hex);\n        hex.sort();\n        return hex.map(e => Buff.hex(e, size));\n    }\n    static calc_varint(num, endian) {\n        if (num < 0xFD) {\n            return Buff.num(num, 1);\n        }\n        else if (num < 0x10000) {\n            return Buff.of(0xFD, ...Buff.num(num, 2, endian));\n        }\n        else if (num < 0x100000000) {\n            return Buff.of(0xFE, ...Buff.num(num, 4, endian));\n        }\n        else if (BigInt(num) < 0x10000000000000000n) {\n            return Buff.of(0xFF, ...Buff.num(num, 8, endian));\n        }\n        else {\n            throw new Error(`Value is too large: ${num}`);\n        }\n    }\n}\nfunction numToBuff(number, size, endian) {\n    return new Buff(number, size, endian);\n}\nfunction binToBuff(data, size, endian) {\n    return new Buff(fmt.binToBytes(data), size, endian);\n}\nfunction bigToBuff(bigint, size, endian) {\n    return new Buff(bigint, size, endian);\n}\nfunction rawToBuff(data, size, endian) {\n    return new Buff(data, size, endian);\n}\nfunction strToBuff(data, size, endian) {\n    return new Buff(fmt.strToBytes(data), size, endian);\n}\nfunction hexToBuff(data, size, endian) {\n    return new Buff(data, size, endian);\n}\nfunction jsonToBuff(data, replacer) {\n    if (replacer === undefined) {\n        replacer = util.bigint_replacer;\n    }\n    const str = JSON.stringify(data, replacer);\n    return new Buff(fmt.strToBytes(str));\n}\nfunction base64ToBuff(data) {\n    return new Buff(encoder.Base64.decode(data));\n}\nfunction b64urlToBuff(data) {\n    return new Buff(encoder.B64url.decode(data));\n}\nfunction bech32ToBuff(data, limit, chk_prefix) {\n    const { decode, to_bytes } = encoder.Bech32;\n    const { prefix, words } = decode(data, limit);\n    const bytes = to_bytes(words);\n    if (typeof chk_prefix === 'string') {\n        assert.is_prefix(prefix, chk_prefix);\n    }\n    return new Buff(bytes);\n}\nfunction bech32mToBuff(data, limit, chk_prefix) {\n    const { decode, to_bytes } = encoder.Bech32m;\n    const { prefix, words } = decode(data, limit);\n    const bytes = to_bytes(words);\n    if (typeof chk_prefix === 'string') {\n        assert.is_prefix(prefix, chk_prefix);\n    }\n    return new Buff(bytes);\n}\nfunction b58chkToBuff(data) {\n    return new Buff(encoder.B58chk.decode(data));\n}\nfunction parse_data(data_blob, chunk_size, total_size) {\n    const bytes = fmt.buffer_data(data_blob);\n    const chunks = util.parse_data(bytes, chunk_size, total_size);\n    return chunks.map(e => Buff.bytes(e));\n}\nfunction is_equal(a, b) {\n    return new Buff(a).hex === new Buff(b).hex;\n}\nexport function buffer(bytes, size, end) {\n    return new Buff(bytes, size, end);\n}\nexport class Stream {\n    constructor(data) {\n        this.data = Buff.bytes(data);\n        this.size = this.data.length;\n    }\n    peek(size) {\n        if (size > this.size) {\n            throw new Error(`Size greater than stream: ${size} > ${this.size}`);\n        }\n        return new Buff(this.data.slice(0, size));\n    }\n    read(size) {\n        const chunk = this.peek(size);\n        this.data = this.data.slice(size);\n        this.size = this.data.length;\n        return chunk;\n    }\n    read_varint(endian) {\n        const num = this.read(1).num;\n        switch (true) {\n            case (num >= 0 && num < 0xFD):\n                return num;\n            case (num === 0xFD):\n                return this.read(2).to_num(endian);\n            case (num === 0xFE):\n                return this.read(4).to_num(endian);\n            case (num === 0xFF):\n                return this.read(8).to_num(endian);\n            default:\n                throw new Error(`Varint is out of range: ${num}`);\n        }\n    }\n}\n//# sourceMappingURL=buff.js.map","export function binToBytes(binary) {\n    const bins = binary.split('').map(Number);\n    if (bins.length % 8 !== 0) {\n        throw new Error(`Binary array is invalid length: ${binary.length}`);\n    }\n    const bytes = new Uint8Array(bins.length / 8);\n    for (let i = 0, ct = 0; i < bins.length; i += 8, ct++) {\n        let byte = 0;\n        for (let j = 0; j < 8; j++) {\n            byte |= (bins[i + j] << (7 - j));\n        }\n        bytes[ct] = byte;\n    }\n    return bytes;\n}\nexport function bytesToBin(bytes) {\n    const bin = new Array(bytes.length * 8);\n    let count = 0;\n    for (const num of bytes) {\n        if (num > 255) {\n            throw new Error(`Invalid byte value: ${num}. Byte values must be between 0 and 255.`);\n        }\n        for (let i = 7; i >= 0; i--, count++) {\n            bin[count] = (num >> i) & 1;\n        }\n    }\n    return bin.join('');\n}\n//# sourceMappingURL=bin.js.map",null,null,null,null,null,"/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u16 = (arr) => new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    else if (isBytes(data))\n        data = data.slice();\n    else\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('options must be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function ensureBytes(b, len) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (typeof len === 'number')\n        if (b.length !== len)\n            throw new Error(`Uint8Array length ${len} expected`);\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n// For runtime check if class implements interface\nexport class Hash {\n}\nexport const wrapCipher = (params, c) => {\n    Object.assign(c, params);\n    return c;\n};\n// Polyfill for Safari 14\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nexport function u64Lengths(ciphertext, AAD) {\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(ciphertext.length), true);\n    return num;\n}\n//# sourceMappingURL=utils.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// TODO: merge with utils\nfunction isBytes(a) {\n    return (a != null &&\n        typeof a === 'object' &&\n        (a instanceof Uint8Array || a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('hash must be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","import { createView, toBytes, u32, ensureBytes } from './utils.js';\nimport { exists as aexists, output as aoutput } from './_assert.js';\n// GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n// Implemented in terms of GHash with conversion function for keys\n// GCM GHASH from NIST SP800-38d, SIV from RFC 8452.\n// https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n// GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n// POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0, s1, s2, s3) => {\n    const hiBit = s3 & 1;\n    return {\n        s3: (s2 << 31) | (s3 >>> 1),\n        s2: (s1 << 31) | (s2 >>> 1),\n        s1: (s0 << 31) | (s1 >>> 1),\n        s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n    };\n};\nconst swapLE = (n) => (((n >>> 0) & 0xff) << 24) |\n    (((n >>> 8) & 0xff) << 16) |\n    (((n >>> 16) & 0xff) << 8) |\n    ((n >>> 24) & 0xff) |\n    0;\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k) {\n    k.reverse();\n    const hiBit = k[15] & 1;\n    // k >>= 1\n    let carry = 0;\n    for (let i = 0; i < k.length; i++) {\n        const t = k[i];\n        k[i] = (t >>> 1) | carry;\n        carry = (t & 1) << 7;\n    }\n    k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n    return k;\n}\nconst estimateWindow = (bytes) => {\n    if (bytes > 64 * 1024)\n        return 8;\n    if (bytes > 1024)\n        return 4;\n    return 2;\n};\nclass GHASH {\n    // We select bits per window adaptively based on expectedLength\n    constructor(key, expectedLength) {\n        this.blockLen = BLOCK_SIZE;\n        this.outputLen = BLOCK_SIZE;\n        this.s0 = 0;\n        this.s1 = 0;\n        this.s2 = 0;\n        this.s3 = 0;\n        this.finished = false;\n        key = toBytes(key);\n        ensureBytes(key, 16);\n        const kView = createView(key);\n        let k0 = kView.getUint32(0, false);\n        let k1 = kView.getUint32(4, false);\n        let k2 = kView.getUint32(8, false);\n        let k3 = kView.getUint32(12, false);\n        // generate table of doubled keys (half of montgomery ladder)\n        const doubles = [];\n        for (let i = 0; i < 128; i++) {\n            doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n            ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n        }\n        const W = estimateWindow(expectedLength || 1024);\n        if (![1, 2, 4, 8].includes(W))\n            throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);\n        this.W = W;\n        const bits = 128; // always 128 bits;\n        const windows = bits / W;\n        const windowSize = (this.windowSize = 2 ** W);\n        const items = [];\n        // Create precompute table for window of W bits\n        for (let w = 0; w < windows; w++) {\n            // truth table: 00, 01, 10, 11\n            for (let byte = 0; byte < windowSize; byte++) {\n                // prettier-ignore\n                let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n                for (let j = 0; j < W; j++) {\n                    const bit = (byte >>> (W - j - 1)) & 1;\n                    if (!bit)\n                        continue;\n                    const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n                    (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n                }\n                items.push({ s0, s1, s2, s3 });\n            }\n        }\n        this.t = items;\n    }\n    _updateBlock(s0, s1, s2, s3) {\n        (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n        const { W, t, windowSize } = this;\n        // prettier-ignore\n        let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n        const mask = (1 << W) - 1; // 2**W will kill performance.\n        let w = 0;\n        for (const num of [s0, s1, s2, s3]) {\n            for (let bytePos = 0; bytePos < 4; bytePos++) {\n                const byte = (num >>> (8 * bytePos)) & 0xff;\n                for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n                    const bit = (byte >>> (W * bitPos)) & mask;\n                    const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n                    (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n                    w += 1;\n                }\n            }\n        }\n        this.s0 = o0;\n        this.s1 = o1;\n        this.s2 = o2;\n        this.s3 = o3;\n    }\n    update(data) {\n        data = toBytes(data);\n        aexists(this);\n        const b32 = u32(data);\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        const left = data.length % BLOCK_SIZE;\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    destroy() {\n        const { t } = this;\n        // clean precompute table\n        for (const elm of t) {\n            (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n        }\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        const { s0, s1, s2, s3 } = this;\n        const o32 = u32(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out;\n    }\n    digest() {\n        const res = new Uint8Array(BLOCK_SIZE);\n        this.digestInto(res);\n        this.destroy();\n        return res;\n    }\n}\nclass Polyval extends GHASH {\n    constructor(key, expectedLength) {\n        key = toBytes(key);\n        const ghKey = _toGHASHKey(key.slice());\n        super(ghKey, expectedLength);\n        ghKey.fill(0);\n    }\n    update(data) {\n        data = toBytes(data);\n        aexists(this);\n        const b32 = u32(data);\n        const left = data.length % BLOCK_SIZE;\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // tmp ugly hack\n        const { s0, s1, s2, s3 } = this;\n        const o32 = u32(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out.reverse();\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes(msg)).digest();\n    const tmp = hashCons(new Uint8Array(16), 0);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key, expectedLength) => hashCons(key, expectedLength);\n    return hashC;\n}\nexport const ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));\nexport const polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));\n//# sourceMappingURL=_polyval.js.map","import { wrapCipher, equalBytes, u32, u8, ensureBytes } from './utils.js';\nimport { createView, setBigUint64 } from './utils.js';\nimport { ghash, polyval } from './_polyval.js';\n// AES (Advanced Encryption Standard) aka Rijndael block cipher.\n//\n// Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256bit). Every round:\n// 1. **S-box**, table substitution\n// 2. **Shift rows**, cyclic shift left of all rows of data array\n// 3. **Mix columns**, multiplying every column by fixed polynomial\n// 4. **Add round key**, round_key xor i-th column of array\n//\n// Resources:\n// - FIPS-197 https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf\n// - Original proposal: https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n// TODO: remove multiplication, binary ops only\nfunction mul2(n) {\n    return (n << 1) ^ (POLY & -(n >> 7));\n}\nfunction mul(a, b) {\n    let res = 0;\n    for (; b > 0; b >>= 1) {\n        // Montgomery ladder\n        res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n        a = mul2(a); // a = 2*a\n    }\n    return res;\n}\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst _sbox = /* @__PURE__ */ (() => {\n    let t = new Uint8Array(256);\n    for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x))\n        t[i] = x;\n    const sbox = new Uint8Array(256);\n    sbox[0] = 0x63; // first elm\n    for (let i = 0; i < 255; i++) {\n        let x = t[255 - i];\n        x |= x << 8;\n        sbox[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n    }\n    return sbox;\n})();\n// Inverted S-box\nconst _inv_sbox = /* @__PURE__ */ _sbox.map((_, j) => _sbox.indexOf(j));\n// Rotate u32 by 8\nconst rotr32_8 = (n) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n) => (n << 8) | (n >>> 24);\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox, fn) {\n    if (sbox.length !== 256)\n        throw new Error('Wrong sbox length');\n    const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n    const T1 = T0.map(rotl32_8);\n    const T2 = T1.map(rotl32_8);\n    const T3 = T2.map(rotl32_8);\n    const T01 = new Uint32Array(256 * 256);\n    const T23 = new Uint32Array(256 * 256);\n    const sbox2 = new Uint16Array(256 * 256);\n    for (let i = 0; i < 256; i++) {\n        for (let j = 0; j < 256; j++) {\n            const idx = i * 256 + j;\n            T01[idx] = T0[i] ^ T1[j];\n            T23[idx] = T2[i] ^ T3[j];\n            sbox2[idx] = (sbox[i] << 8) | sbox[j];\n        }\n    }\n    return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\nconst TABLE_ENC = /* @__PURE__ */ genTtable(_sbox, (s) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2));\nconst TABLE_DEC = /* @__PURE__ */ genTtable(_inv_sbox, (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14));\nconst POWX = /* @__PURE__ */ (() => {\n    const p = new Uint8Array(16);\n    for (let i = 0, x = 1; i < 16; i++, x = mul2(x))\n        p[i] = x;\n    return p;\n})();\nexport function expandKeyLE(key) {\n    ensureBytes(key);\n    const len = key.length;\n    if (![16, 24, 32].includes(len))\n        throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);\n    const { sbox2 } = TABLE_ENC;\n    const k32 = u32(key);\n    const Nk = k32.length;\n    const subByte = (n) => applySbox(sbox2, n, n, n, n);\n    const xk = new Uint32Array(len + 28); // expanded key\n    xk.set(k32);\n    // 4.3.1 Key expansion\n    for (let i = Nk; i < xk.length; i++) {\n        let t = xk[i - 1];\n        if (i % Nk === 0)\n            t = subByte(rotr32_8(t)) ^ POWX[i / Nk - 1];\n        else if (Nk > 6 && i % Nk === 4)\n            t = subByte(t);\n        xk[i] = xk[i - Nk] ^ t;\n    }\n    return xk;\n}\nexport function expandKeyDecLE(key) {\n    const encKey = expandKeyLE(key);\n    const xk = encKey.slice();\n    const Nk = encKey.length;\n    const { sbox2 } = TABLE_ENC;\n    const { T0, T1, T2, T3 } = TABLE_DEC;\n    // Inverse key by chunks of 4 (rounds)\n    for (let i = 0; i < Nk; i += 4) {\n        for (let j = 0; j < 4; j++)\n            xk[i + j] = encKey[Nk - i - 4 + j];\n    }\n    encKey.fill(0);\n    // apply InvMixColumn except first & last round\n    for (let i = 4; i < Nk - 4; i++) {\n        const x = xk[i];\n        const w = applySbox(sbox2, x, x, x, x);\n        xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n    }\n    return xk;\n}\n// Apply tables\nfunction apply0123(T01, T23, s0, s1, s2, s3) {\n    return (T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n        T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]);\n}\nfunction applySbox(sbox2, s0, s1, s2, s3) {\n    return (sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n        (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16));\n}\nfunction encrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = TABLE_ENC;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // last round (without mixcolumns, so using SBOX2 table)\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction decrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = TABLE_DEC;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // Last round\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction getDst(len, dst) {\n    if (!dst)\n        return new Uint8Array(len);\n    ensureBytes(dst);\n    if (dst.length < len)\n        throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);\n    return dst;\n}\n// TODO: investigate merging with ctr32\nfunction ctrCounter(xk, nonce, src, dst) {\n    ensureBytes(nonce, BLOCK_SIZE);\n    ensureBytes(src);\n    const srcLen = src.length;\n    dst = getDst(srcLen, dst);\n    const ctr = nonce;\n    const c32 = u32(ctr);\n    // Fill block (empty, ctr=0)\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    const src32 = u32(src);\n    const dst32 = u32(dst);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        // Full 128 bit counter with wrap around\n        let carry = 1;\n        for (let i = ctr.length - 1; i >= 0; i--) {\n            carry = (carry + (ctr[i] & 0xff)) | 0;\n            ctr[i] = carry & 0xff;\n            carry >>>= 8;\n        }\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than block)\n    // It's possible to handle > u32 fast, but is it worth it?\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = u8(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(xk, isLE, nonce, src, dst) {\n    ensureBytes(nonce, BLOCK_SIZE);\n    ensureBytes(src);\n    dst = getDst(src.length, dst);\n    const ctr = nonce; // write new value to nonce, so it can be re-used\n    const c32 = u32(ctr);\n    const view = createView(ctr);\n    const src32 = u32(src);\n    const dst32 = u32(dst);\n    const ctrPos = isLE ? 0 : 12;\n    const srcLen = src.length;\n    // Fill block (empty, ctr=0)\n    let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n        view.setUint32(ctrPos, ctrNum, isLE);\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than a block)\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = u8(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function ctr(key, nonce) {\n    ensureBytes(key);\n    ensureBytes(nonce, BLOCK_SIZE);\n    function processCtr(buf, dst) {\n        const xk = expandKeyLE(key);\n        const n = nonce.slice();\n        const out = ctrCounter(xk, n, buf, dst);\n        xk.fill(0);\n        n.fill(0);\n        return out;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCtr(plaintext, dst),\n        decrypt: (ciphertext, dst) => processCtr(ciphertext, dst),\n    };\n});\nfunction validateBlockDecrypt(data) {\n    ensureBytes(data);\n    if (data.length % BLOCK_SIZE !== 0) {\n        throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`);\n    }\n}\nfunction validateBlockEncrypt(plaintext, pcks5, dst) {\n    let outLen = plaintext.length;\n    const remaining = outLen % BLOCK_SIZE;\n    if (!pcks5 && remaining !== 0)\n        throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n    const b = u32(plaintext);\n    if (pcks5) {\n        let left = BLOCK_SIZE - remaining;\n        if (!left)\n            left = BLOCK_SIZE; // if no bytes left, create empty padding block\n        outLen = outLen + left;\n    }\n    const out = getDst(outLen, dst);\n    const o = u32(out);\n    return { b, o, out };\n}\nfunction validatePCKS(data, pcks5) {\n    if (!pcks5)\n        return data;\n    const len = data.length;\n    if (!len)\n        throw new Error(`aes/pcks5: empty ciphertext not allowed`);\n    const lastByte = data[len - 1];\n    if (lastByte <= 0 || lastByte > 16)\n        throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);\n    const out = data.subarray(0, -lastByte);\n    for (let i = 0; i < lastByte; i++)\n        if (data[len - i - 1] !== lastByte)\n            throw new Error(`aes/pcks5: wrong padding`);\n    return out;\n}\nfunction padPCKS(left) {\n    const tmp = new Uint8Array(16);\n    const tmp32 = u32(tmp);\n    tmp.set(left);\n    const paddingByte = BLOCK_SIZE - left.length;\n    for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++)\n        tmp[i] = paddingByte;\n    return tmp32;\n}\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb = wrapCipher({ blockSize: 16 }, function ecb(key, opts = {}) {\n    ensureBytes(key);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            ensureBytes(plaintext);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const xk = expandKeyLE(key);\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const out = getDst(ciphertext.length, dst);\n            const b = u32(ciphertext);\n            const o = u32(out);\n            for (let i = 0; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function cbc(key, iv, opts = {}) {\n    ensureBytes(key);\n    ensureBytes(iv, 16);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            const xk = expandKeyLE(key);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const n32 = u32(iv);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const n32 = u32(iv);\n            const out = getDst(ciphertext.length, dst);\n            const b = u32(ciphertext);\n            const o = u32(out);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            for (let i = 0; i + 4 <= b.length;) {\n                // prettier-ignore\n                const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n                (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n                const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n                (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(fn, isLE, key, data, AAD) {\n    const h = fn.create(key, data.length + (AAD?.length || 0));\n    if (AAD)\n        h.update(AAD);\n    h.update(data);\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    if (AAD)\n        setBigUint64(view, 0, BigInt(AAD.length * 8), isLE);\n    setBigUint64(view, 8, BigInt(data.length * 8), isLE);\n    h.update(num);\n    return h.digest();\n}\n/**\n * GCM: Galois/Counter Mode.\n * Good, modern version of CTR, parallel, with MAC.\n * Be careful: MACs can be forged.\n */\nexport const gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm(key, nonce, AAD) {\n    ensureBytes(nonce);\n    // Nonce can be pretty much anything (even 1 byte). But smaller nonces less secure.\n    if (nonce.length === 0)\n        throw new Error('aes/gcm: empty nonce');\n    const tagLength = 16;\n    function _computeTag(authKey, tagMask, data) {\n        const tag = computeTag(ghash, false, authKey, data, AAD);\n        for (let i = 0; i < tagMask.length; i++)\n            tag[i] ^= tagMask[i];\n        return tag;\n    }\n    function deriveKeys() {\n        const xk = expandKeyLE(key);\n        const authKey = EMPTY_BLOCK.slice();\n        const counter = EMPTY_BLOCK.slice();\n        ctr32(xk, false, counter, counter, authKey);\n        if (nonce.length === 12) {\n            counter.set(nonce);\n        }\n        else {\n            // Spec (NIST 800-38d) supports variable size nonce.\n            // Not supported for now, but can be useful.\n            const nonceLen = EMPTY_BLOCK.slice();\n            const view = createView(nonceLen);\n            setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n            // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n            ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);\n        }\n        const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n        return { xk, authKey, counter, tagMask };\n    }\n    return {\n        encrypt: (plaintext) => {\n            ensureBytes(plaintext);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const out = new Uint8Array(plaintext.length + tagLength);\n            ctr32(xk, false, counter, plaintext, out);\n            const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n            out.set(tag, plaintext.length);\n            xk.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            ensureBytes(ciphertext);\n            if (ciphertext.length < tagLength)\n                throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = _computeTag(authKey, tagMask, data);\n            if (!equalBytes(tag, passedTag))\n                throw new Error('aes/gcm: invalid ghash tag');\n            const out = ctr32(xk, false, counter, data);\n            authKey.fill(0);\n            tagMask.fill(0);\n            xk.fill(0);\n            return out;\n        },\n    };\n});\nconst limit = (name, min, max) => (value) => {\n    if (!Number.isSafeInteger(value) || min > value || value > max)\n        throw new Error(`${name}: invalid value=${value}, must be [${min}..${max}]`);\n};\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const siv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv(key, nonce, AAD) {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    ensureBytes(nonce);\n    NONCE_LIMIT(nonce.length);\n    if (AAD) {\n        ensureBytes(AAD);\n        AAD_LIMIT(AAD.length);\n    }\n    function deriveKeys() {\n        const len = key.length;\n        if (len !== 16 && len !== 24 && len !== 32)\n            throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);\n        const xk = expandKeyLE(key);\n        const encKey = new Uint8Array(len);\n        const authKey = new Uint8Array(16);\n        const n32 = u32(nonce);\n        // prettier-ignore\n        let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n        let counter = 0;\n        for (const derivedKey of [authKey, encKey].map(u32)) {\n            const d32 = u32(derivedKey);\n            for (let i = 0; i < d32.length; i += 2) {\n                // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n                const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n                d32[i + 0] = o0;\n                d32[i + 1] = o1;\n                s0 = ++counter; // increment counter inside state\n            }\n        }\n        xk.fill(0);\n        return { authKey, encKey: expandKeyLE(encKey) };\n    }\n    function _computeTag(encKey, authKey, data) {\n        const tag = computeTag(polyval, true, authKey, data, AAD);\n        // Compute the expected tag by XORing S_s and the nonce, clearing the\n        // most significant bit of the last byte and encrypting with the\n        // message-encryption key.\n        for (let i = 0; i < 12; i++)\n            tag[i] ^= nonce[i];\n        tag[15] &= 0x7f; // Clear the highest bit\n        // encrypt tag as block\n        const t32 = u32(tag);\n        // prettier-ignore\n        let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n        ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n        (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n        return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey, tag, input) {\n        let block = tag.slice();\n        block[15] |= 0x80; // Force highest bit\n        return ctr32(encKey, true, block, input);\n    }\n    return {\n        encrypt: (plaintext) => {\n            ensureBytes(plaintext);\n            PLAIN_LIMIT(plaintext.length);\n            const { encKey, authKey } = deriveKeys();\n            const tag = _computeTag(encKey, authKey, plaintext);\n            const out = new Uint8Array(plaintext.length + tagLength);\n            out.set(tag, plaintext.length);\n            out.set(processSiv(encKey, tag, plaintext));\n            encKey.fill(0);\n            authKey.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            ensureBytes(ciphertext);\n            CIPHER_LIMIT(ciphertext.length);\n            const tag = ciphertext.subarray(-tagLength);\n            const { encKey, authKey } = deriveKeys();\n            const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n            const expectedTag = _computeTag(encKey, authKey, plaintext);\n            encKey.fill(0);\n            authKey.fill(0);\n            if (!equalBytes(tag, expectedTag))\n                throw new Error('invalid polyval tag');\n            return plaintext;\n        },\n    };\n});\nfunction isBytes32(a) {\n    return (a != null &&\n        typeof a === 'object' &&\n        (a instanceof Uint32Array || a.constructor.name === 'Uint32Array'));\n}\nfunction encryptBlock(xk, block) {\n    ensureBytes(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_encryptBlock accepts result of expandKeyLE');\n    const b32 = u32(block);\n    let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\nfunction decryptBlock(xk, block) {\n    ensureBytes(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_decryptBlock accepts result of expandKeyLE');\n    const b32 = u32(block);\n    let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\n// Highly unsafe private functions for implementing new modes or ciphers based on AES\n// Can change at any time, no API guarantees\nexport const unsafe = {\n    expandKeyLE,\n    expandKeyDecLE,\n    encrypt,\n    decrypt,\n    encryptBlock,\n    decryptBlock,\n    ctrCounter,\n    ctr32,\n};\n//# sourceMappingURL=aes.js.map",null,"import { hash as assertHash, number as assertNumber } from './_assert.js';\nimport { hmac } from './hmac.js';\nimport { createView, toBytes, checkOpts, asyncLoop } from './utils.js';\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    assertHash(hash);\n    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    assertNumber(c);\n    assertNumber(dkLen);\n    assertNumber(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = toBytes(_password);\n    const salt = toBytes(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nexport function pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexport async function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await asyncLoop(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map",null,null,null,null,null,null,null,null],"names":["number","n","Number","isSafeInteger","Error","bytes","b","lengths","a","Uint8Array","constructor","name","length","includes","hash","create","outputLen","blockLen","exists","instance","checkFinished","destroyed","finished","crypto","globalThis","undefined","isBytes","createView","arr","DataView","buffer","byteOffset","byteLength","rotr","word","shift","Uint32Array","toBytes","data","str","TextEncoder","encode","utf8ToBytes","Hash","clone","this","_cloneInto","toStr","toString","wrapConstructor","hashCons","hashC","msg","update","digest","tmp","randomBytes","bytesLength","getRandomValues","SHA2","padOffset","isLE","super","pos","view","len","take","Math","min","set","subarray","process","dataView","roundClean","digestInto","out","output","fill","i","value","setBigUint64","_32n","BigInt","_u32_max","wh","wl","h","l","setUint32","oview","outLen","state","get","res","slice","destroy","to","Maj","c","SHA256_K","IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","offset","getUint32","W15","W2","s0","s1","T1","T2","sha256","_0n","_1n","_2n","hexes","Array","from","_","padStart","bytesToHex","hex","numberToHexUnpadded","num","hexToNumber","asciis","_0","_9","_A","_F","_a","_f","asciiToBase16","char","hexToBytes","hl","al","array","ai","hi","n1","charCodeAt","n2","bytesToNumberBE","bytesToNumberLE","reverse","numberToBytesBE","numberToBytesLE","ensureBytes","title","expectedLength","e","concatBytes","arrays","sum","pad","bitMask","u8n","u8fr","createHmacDrbg","hashLen","qByteLen","hmacFn","v","k","reset","reseed","seed","gen","sl","push","pred","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","isArray","field","object","Fp","isValid","validateObject","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","Object","entries","diff","_3n","_4n","_5n","_8n","mod","result","pow","power","modulo","pow2","x","invert","u","r","m","FpSqrt","P","p1div4","root","eql","sqr","c1","mul","nv","sub","ONE","legendreC","Q","S","Z","Q1div2","neg","g","ZERO","t2","ge","tonelliShanks","FIELD_FIELDS","nLength","nBitLength","_nBitLength","nByteLength","ceil","Field","ORDER","bitLen","redef","BITS","BYTES","sqrtP","f","freeze","MASK","is0","isOdd","lhs","rhs","add","p","d","FpPow","div","sqrN","addN","subN","mulN","inv","sqrt","invertBatch","lst","nums","lastMultiplied","reduce","acc","inverted","reduceRight","FpInvertBatch","cmov","fromBytes","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","validateBasic","curve","map","Gx","Gy","b2n","h2b","ut","DER","Err","_parseInt","toSig","ut.isBytes","sBytes","s","rBytesLeft","hexFromSig","sig","parseInt","shl","rhl","rl","weierstrassPoints","opts","CURVE","ut.validateObject","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","endo","beta","splitScalar","validatePointOpts","_c","point","_isCompressed","toAffine","ut.concatBytes","y","tail","weierstrassEquation","x2","x3","isWithinCurveOrder","assertGE","normPrivateKeyToScalar","key","ut.bytesToHex","ut.bytesToNumberBE","error","mod.mod","pointPrecomputes","Map","assertPrjPoint","other","Point","px","py","pz","fromAffine","normalizeZ","points","toInv","fromHex","assertValidity","fromPrivateKey","privateKey","BASE","multiply","_setWindowSize","windowSize","_WINDOW_SIZE","delete","left","right","hasEvenY","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","double","b3","X3","Y3","Z3","t0","t1","t3","t4","t5","subtract","wNAF","wnaf","wNAFCached","comp","multiplyUnsafe","I","unsafeLadder","k1neg","k1","k2neg","k2","k1p","k2p","scalar","fake","f1p","f2p","constTimeNegate","multiplyAndAddUnsafe","iz","z","ax","ay","zz","cofactor","toRawBytes","isCompressed","toHex","_bits","bits","condition","item","W","windows","elm","precomputeWindow","base","window","precomputes","mask","maxNumber","shiftBy","wbits","offset1","offset2","abs","cond1","cond2","precomputesMap","transform","ProjectivePoint","weierstrass","curveDef","hmac","bits2int","bits2int_modN","lowS","validateOpts","CURVE_ORDER","compressedLen","uncompressedLen","modN","invN","mod.invert","cat","head","y2","numToNByteStr","ut.numberToBytesBE","isBiggerThanHalfOrder","slcNum","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","prefix","R","ir","u1","u2","hasHighS","normalizeS","toDERRawBytes","ut.hexToBytes","toDERHex","toCompactRawBytes","toCompactHex","utils","isValidPrivateKey","randomPrivateKey","mod.getMinHashLength","fieldLen","minLen","reduced","mod.mapHashToField","precompute","isProbPub","delta","ORDER_MASK","ut.bitMask","int2octets","prepSig","defaultSigOpts","some","prehash","extraEntropy","ent","h1int","seedArgs","k2sig","kBytes","ik","q","normS","defaultVerOpts","getPublicKey","getSharedSecret","privateA","publicB","sign","privKey","ut.createHmacDrbg","drbg","verify","signature","publicKey","sg","_sig","derError","message","is","HMAC","_key","assertHash","iHash","oHash","buf","assertExists","assertBytes","getPrototypeOf","getHash","msgs","secp256k1P","secp256k1N","divNearest","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b2","b6","b9","b11","b22","b44","b88","b176","b220","b223","secp256k1","defHash","createCurve","a1","b1","a2","POW_2_128","c2","fe","TAGGED_HASH_PREFIXES","taggedHash","tag","messages","tagP","tagH","pointToBytes","numTo32b","modP","GmulAdd","schnorrGetExtPubKey","priv","d_","lift_x","xx","challenge","args","schnorrGetPublicKey","schnorrSign","auxRand","t","rand","k_","rx","schnorrVerify","pub","schnorr","is_safe_num","MAX_SAFE_INTEGER","TypeError","is_prefix","actual","target","ec","dc","TextDecoder","strToBytes","bytesToStr","decode","hex_size","hexstr","size","match","is_hex","chain","id","wrap","alphabet","digits","input","letter","index","indexOf","join","separator","split","convertRadix","forEach","carry","done","digit","digitBase","rounded","floor","gcd","radix2carry","convertRadix2","padding","radix2","revPadding","unsafeWrapper","fn","apply","base64","chr","end","base64urlnopad","genBase58","abc","base58","base58check","checksum","payload","newChecksum","oldChecksum","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","words","encodingConst","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","lowered","toLowerCase","toUpperCase","sepIndex","lastIndexOf","endsWith","actualLength","decodeToBytes","decodeUnsafe","bech32","bech32m","B58chk","Base64","B64url","Bech32","to_words","to_bytes","Bech32m","_255n","_256n","bigToBytes","big","endian","big_size","use_le","ArrayBuffer","byte","setUint8","numToBytes","num_size","is_bytes","every","set_buffer","within_size","join_array","buff","bigint_replacer","bigint_reviver","test","buffer_data","util.set_buffer","util.join_array","substring","of","Buff","numToBuff","bigToBuff","bin","binToBuff","raw","rawToBuff","strToBuff","hexToBuff","json","jsonToBuff","base64ToBuff","b64url","b64urlToBuff","bech32ToBuff","bech32mToBuff","b58chk","b58chkToBuff","fmt.strToBytes","fmt.bytesToStr","parse","parse_data","util.is_bytes","util.is_hex","is_equal","random","now","stamp","Date","fmt.buffer_data","to_num","to_big","to_str","to_hex","to_bin","to_b58chk","to_base64","to_b64url","to_hash","stream","Stream","fmt.bytesToNum","fmt.bytesToBig","count","fmt.bytesToBin","to_json","reviver","util.bigint_reviver","JSON","to_bech32","encoder.Bech32","to_bech32m","encoder.Bech32m","chars","fmt.bytesToHex","encoder.B58chk","encoder.Base64","encoder.B64url","append","prepend","start","begin","write","add_varint","calc_varint","toJSON","joined","sort","binary","bins","ct","j","fmt.binToBytes","replacer","util.bigint_replacer","stringify","chk_prefix","assert.is_prefix","data_blob","chunk_size","total_size","chunks","idx","util.parse_data","peek","read","chunk","read_varint","_N","_P","_G","ECPoint","Noble","is_even","is_point","is_valid","pt","pa","pb","pc","xonly","parity","fd","GF","mod_n","sqrt_n","sqrt_p","exp","fail","throws","on_curve","in_field","valid_chain","path","code","startsWith","valid_path","valid_index","hardened","is_private","pubkey","NoblePoint","N","assert.in_field","math.mod_n","normalizeField","generate","hasOddY","negated","gt","lt","eq","ne","math.fd","import","from_x","even_y","cp","normalizePoint","assert.size","_p","u8","u32","equalBytes","wrapCipher","params","assign","BLOCK_SIZE","ZEROS16","ZEROS32","swapLE","GHASH","s2","s3","kView","k0","k3","doubles","estimateWindow","items","w","d0","d1","d2","d3","_updateBlock","o0","o1","o2","o3","bytePos","bitPos","bit","e0","e1","e2","e3","aexists","b32","blocks","aoutput","o32","Polyval","ghKey","hiBit","_toGHASHKey","wrapConstructorWithKey","ghash","polyval","EMPTY_BLOCK","POLY","mul2","_sbox","sbox","_inv_sbox","rotr32_8","rotl32_8","genTtable","T0","T3","T01","T23","sbox2","Uint16Array","TABLE_ENC","TABLE_DEC","POWX","expandKeyLE","k32","Nk","subByte","applySbox","xk","expandKeyDecLE","encKey","apply0123","encrypt","rounds","decrypt","getDst","dst","ctr32","nonce","src","ctr","c32","src32","dst32","ctrPos","srcLen","ctrNum","validateBlockDecrypt","validateBlockEncrypt","plaintext","pcks5","remaining","o","validatePCKS","lastByte","padPCKS","tmp32","paddingByte","blockSize","nonceLength","processCtr","ctrCounter","ciphertext","disablePadding","_out","cbc","iv","n32","ps0","ps1","ps2","ps3","computeTag","AAD","gcm","tagLength","_computeTag","authKey","tagMask","deriveKeys","counter","nonceLen","passedTag","max","AAD_LIMIT","PLAIN_LIMIT","NONCE_LIMIT","CIPHER_LIMIT","derivedKey","d32","t32","processSiv","block","expectedTag","secret","vector","dat","sec","vec","dec","enc","pbkdf2Init","_password","_salt","_opts","defaults","call","checkOpts","dkLen","asyncTick","assertNumber","password","salt","DK","PRF","PRFSalt","pbkdf2","prfW","ti","Ti","setInt32","ui","pbkdf2Output","U32_MASK64","fromBig","le","u64","Ah","Al","toBig","shrSH","_l","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","rotr32H","_h","rotr32L","rotlSH","rotlSL","rotlBH","rotlBL","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5H","Eh","add5L","El","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA512","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","CHIl","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","sha512","Rho","Id","idxL","idxR","shifts","shiftsL","shiftsR","Kl","Kr","rotl","group","BUF","RIPEMD160","h0","h1","h2","h3","h4","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rr","sr","tl","tr","ripemd160","s256","hash160","r160","hmac512","s512","taghash","hash340","slt","content","get_seckey","get_pubkey","seckey","x_only","get_keypair","convert_32b","convert_33b","keys","tweaks","twk","INT_REGEX","STR_REGEX","derive_key","input_key","chain_code","assert.valid_chain","prev","generate_code","parse_tweaks","tweak","is_hardened","next_key","next_code","assert.on_curve","keypath","assert.valid_path","paths","assert.valid_index","chain_data","parse_extkey","keyhex","depth","fprint","chaincode","key_link","key_prefix","tprev","at","merkleize_tree","tree","encoder","encode_branch","leaves","branches","leaf","branch","gen_nonce","options","aux","nonce_seed","nonce_tweak","sec_nonce","sn","s_val","chal","adaptor","key_tweak","dp","kp","ch","assert.fail","sG","eP","shares","numer","denom","thold","total","coeffs","coeff","share","noble","secp"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,27,28,29,30,32,33,34,35]}